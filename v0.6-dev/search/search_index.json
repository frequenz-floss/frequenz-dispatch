{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Highlevel Interface","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A highlevel interface for the dispatch API.</p> <p>See the documentation for more information.</p>"},{"location":"#usage","title":"Usage","text":"<p>The <code>Dispatcher</code> class, the main entry point for the API, provides two channels:</p> <ul> <li>Lifecycle events: A channel that sends a message whenever a Dispatch is created, updated or deleted.</li> <li>Running status change: Sends a dispatch message whenever a dispatch is ready to be executed according to the schedule or the running status of the dispatch changed in a way that could potentially require the actor to start, stop or reconfigure itself.</li> </ul>"},{"location":"#example-using-the-running-status-change-channel","title":"Example using the running status change channel","text":"<pre><code>import os\nfrom frequenz.dispatch import Dispatcher\nfrom unittest.mock import MagicMock\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()\n\n    actor = MagicMock() # replace with your actor\n\n    changed_running_status_rx = dispatcher.new_running_state_event_receiver(\"MY_TYPE\")\n\n    async for dispatch in changed_running_status_rx:\n        if dispatch.started:\n            print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n            if actor.is_running:\n                actor.reconfigure(\n                    components=dispatch.target,\n                    run_parameters=dispatch.payload, # custom actor parameters\n                    dry_run=dispatch.dry_run,\n                    until=dispatch.until,\n                )  # this will reconfigure the actor\n            else:\n                # this will start a new actor with the given components\n                # and run it for the duration of the dispatch\n                actor.start(\n                    components=dispatch.target,\n                    run_parameters=dispatch.payload, # custom actor parameters\n                    dry_run=dispatch.dry_run,\n                    until=dispatch.until,\n                )\n        else:\n            actor.stop()  # this will stop the actor\n</code></pre>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Dispatch Highlevel Interface","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>dispatch</li> </ul> </li> </ul>"},{"location":"reference/frequenz/dispatch/","title":"dispatch","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch","title":"frequenz.dispatch","text":"<p>A highlevel interface for the dispatch API.</p> <p>A small overview of the most important classes in this module:</p> <ul> <li>Dispatcher: The entry point for the API.</li> <li>Dispatch: A dispatch type with lots of useful extra functionality.</li> <li>ActorDispatcher: A service to manage other actors based on   incoming dispatches.</li> <li>Created,   Updated,   Deleted: Dispatch event types.</li> </ul>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchEvent","title":"frequenz.dispatch.DispatchEvent  <code>module-attribute</code>","text":"<pre><code>DispatchEvent = Created | Updated | Deleted\n</code></pre> <p>Type that is sent over the channel for dispatch updates.</p> <p>This type is used to send dispatches that were created, updated or deleted over the channel.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch-classes","title":"Classes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher","title":"frequenz.dispatch.ActorDispatcher","text":"<p>               Bases: <code>BackgroundService</code></p> <p>Helper class to manage actors based on dispatches.</p> <p>Example usage:</p> <pre><code>import os\nimport asyncio\nfrom typing import override\nfrom frequenz.dispatch import Dispatcher, DispatchManagingActor, DispatchInfo\nfrom frequenz.client.dispatch.types import TargetComponents\nfrom frequenz.client.common.microgrid.components import ComponentCategory\nfrom frequenz.channels import Receiver, Broadcast, select, selected_from\nfrom frequenz.sdk.actor import Actor, run\n\nclass MyActor(Actor):\n    def __init__(\n            self,\n            *,\n            name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._dispatch_updates_receiver: Receiver[DispatchInfo] | None = None\n        self._dry_run: bool = False\n        self._options: dict[str, Any] = {}\n\n    @classmethod\n    def new_with_dispatch(\n            cls,\n            initial_dispatch: DispatchInfo,\n            dispatch_updates_receiver: Receiver[DispatchInfo],\n            *,\n            name: str | None = None,\n    ) -&gt; \"Self\":\n        self = cls(name=name)\n        self._dispatch_updates_receiver = dispatch_updates_receiver\n        self._update_dispatch_information(initial_dispatch)\n        return self\n\n    @override\n    async def _run(self) -&gt; None:\n        other_recv: Receiver[Any] = ...\n\n        if self._dispatch_updates_receiver is None:\n            async for msg in other_recv:\n                # do stuff\n                ...\n        else:\n            await self._run_with_dispatch(other_recv)\n\n    async def _run_with_dispatch(self, other_recv: Receiver[Any]) -&gt; None:\n        async for selected in select(self._dispatch_updates_receiver, other_recv):\n            if selected_from(selected, self._dispatch_updates_receiver):\n                self._update_dispatch_information(selected.message)\n            elif selected_from(selected, other_recv):\n                # do stuff\n                ...\n            else:\n                assert False, f\"Unexpected selected receiver: {selected}\"\n\n    def _update_dispatch_information(self, dispatch_update: DispatchInfo) -&gt; None:\n        print(\"Received update:\", dispatch_update)\n        self._dry_run = dispatch_update.dry_run\n        self._options = dispatch_update.options\n        match dispatch_update.components:\n            case []:\n                print(\"Dispatch: Using all components\")\n            case list() as ids if isinstance(ids[0], int):\n                component_ids = ids\n            case [ComponentCategory.BATTERY, *_]:\n                component_category = ComponentCategory.BATTERY\n            case unsupported:\n                print(\n                    \"Dispatch: Requested an unsupported selector %r, \"\n                    \"but only component IDs or category BATTERY are supported.\",\n                    unsupported,\n                )\n\nasync def main():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    dispatcher.start()\n\n    status_receiver = dispatcher.new_running_state_event_receiver(\"EXAMPLE_TYPE\")\n\n    managing_actor = DispatchManagingActor(\n        actor_factory=MyActor.new_with_dispatch,\n        running_status_receiver=status_receiver,\n    )\n\n    await run(managing_actor)\n</code></pre> Source code in <code>frequenz/dispatch/_actor_dispatcher.py</code> <pre><code>class ActorDispatcher(BackgroundService):\n    \"\"\"Helper class to manage actors based on dispatches.\n\n    Example usage:\n\n    ```python\n    import os\n    import asyncio\n    from typing import override\n    from frequenz.dispatch import Dispatcher, DispatchManagingActor, DispatchInfo\n    from frequenz.client.dispatch.types import TargetComponents\n    from frequenz.client.common.microgrid.components import ComponentCategory\n    from frequenz.channels import Receiver, Broadcast, select, selected_from\n    from frequenz.sdk.actor import Actor, run\n\n    class MyActor(Actor):\n        def __init__(\n                self,\n                *,\n                name: str | None = None,\n        ) -&gt; None:\n            super().__init__(name=name)\n            self._dispatch_updates_receiver: Receiver[DispatchInfo] | None = None\n            self._dry_run: bool = False\n            self._options: dict[str, Any] = {}\n\n        @classmethod\n        def new_with_dispatch(\n                cls,\n                initial_dispatch: DispatchInfo,\n                dispatch_updates_receiver: Receiver[DispatchInfo],\n                *,\n                name: str | None = None,\n        ) -&gt; \"Self\":\n            self = cls(name=name)\n            self._dispatch_updates_receiver = dispatch_updates_receiver\n            self._update_dispatch_information(initial_dispatch)\n            return self\n\n        @override\n        async def _run(self) -&gt; None:\n            other_recv: Receiver[Any] = ...\n\n            if self._dispatch_updates_receiver is None:\n                async for msg in other_recv:\n                    # do stuff\n                    ...\n            else:\n                await self._run_with_dispatch(other_recv)\n\n        async def _run_with_dispatch(self, other_recv: Receiver[Any]) -&gt; None:\n            async for selected in select(self._dispatch_updates_receiver, other_recv):\n                if selected_from(selected, self._dispatch_updates_receiver):\n                    self._update_dispatch_information(selected.message)\n                elif selected_from(selected, other_recv):\n                    # do stuff\n                    ...\n                else:\n                    assert False, f\"Unexpected selected receiver: {selected}\"\n\n        def _update_dispatch_information(self, dispatch_update: DispatchInfo) -&gt; None:\n            print(\"Received update:\", dispatch_update)\n            self._dry_run = dispatch_update.dry_run\n            self._options = dispatch_update.options\n            match dispatch_update.components:\n                case []:\n                    print(\"Dispatch: Using all components\")\n                case list() as ids if isinstance(ids[0], int):\n                    component_ids = ids\n                case [ComponentCategory.BATTERY, *_]:\n                    component_category = ComponentCategory.BATTERY\n                case unsupported:\n                    print(\n                        \"Dispatch: Requested an unsupported selector %r, \"\n                        \"but only component IDs or category BATTERY are supported.\",\n                        unsupported,\n                    )\n\n    async def main():\n        url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n        key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n        microgrid_id = 1\n\n        dispatcher = Dispatcher(\n            microgrid_id=microgrid_id,\n            server_url=url,\n            key=key\n        )\n        dispatcher.start()\n\n        status_receiver = dispatcher.new_running_state_event_receiver(\"EXAMPLE_TYPE\")\n\n        managing_actor = DispatchManagingActor(\n            actor_factory=MyActor.new_with_dispatch,\n            running_status_receiver=status_receiver,\n        )\n\n        await run(managing_actor)\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        actor_factory: Callable[[DispatchInfo, Receiver[DispatchInfo]], Actor],\n        running_status_receiver: Receiver[Dispatch],\n    ) -&gt; None:\n        \"\"\"Initialize the dispatch handler.\n\n        Args:\n            actor_factory: A callable that creates an actor with some initial dispatch\n                information.\n            running_status_receiver: The receiver for dispatch running status changes.\n        \"\"\"\n        super().__init__()\n        self._dispatch_rx = running_status_receiver\n        self._actor_factory = actor_factory\n        self._actor: Actor | None = None\n        self._updates_channel = Broadcast[DispatchInfo](\n            name=\"dispatch_updates_channel\", resend_latest=True\n        )\n        self._updates_sender = self._updates_channel.new_sender()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the background service.\"\"\"\n        self._tasks.add(asyncio.create_task(self._run()))\n\n    async def _start_actor(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Start all actors.\"\"\"\n        dispatch_update = DispatchInfo(\n            components=dispatch.target,\n            dry_run=dispatch.dry_run,\n            options=dispatch.payload,\n        )\n\n        if self._actor:\n            sent_str = \"\"\n            if self._updates_sender is not None:\n                sent_str = \", sent a dispatch update instead of creating a new actor\"\n                await self._updates_sender.send(dispatch_update)\n            _logger.warning(\n                \"Actor for dispatch type %r is already running%s\",\n                dispatch.type,\n                sent_str,\n            )\n        else:\n            _logger.info(\"Starting actor for dispatch type %r\", dispatch.type)\n            self._actor = self._actor_factory(\n                dispatch_update, self._updates_channel.new_receiver()\n            )\n            self._actor.start()\n\n    async def _stop_actor(self, stopping_dispatch: Dispatch, msg: str) -&gt; None:\n        \"\"\"Stop all actors.\n\n        Args:\n            stopping_dispatch: The dispatch that is stopping the actor.\n            msg: The message to be passed to the actors being stopped.\n        \"\"\"\n        if self._actor is None:\n            _logger.warning(\n                \"Actor for dispatch type %r is not running\", stopping_dispatch.type\n            )\n        else:\n            await self._actor.stop(msg)\n            self._actor = None\n\n    async def _run(self) -&gt; None:\n        \"\"\"Wait for dispatches and handle them.\"\"\"\n        async for dispatch in self._dispatch_rx:\n            await self._handle_dispatch(dispatch=dispatch)\n\n    async def _handle_dispatch(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Handle a dispatch.\n\n        Args:\n            dispatch: The dispatch to handle.\n        \"\"\"\n        if dispatch.started:\n            await self._start_actor(dispatch)\n        else:\n            await self._stop_actor(dispatch, \"Dispatch stopped\")\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>None</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__init__","title":"__init__","text":"<pre><code>__init__(\n    actor_factory: Callable[\n        [DispatchInfo, Receiver[DispatchInfo]], Actor\n    ],\n    running_status_receiver: Receiver[Dispatch],\n) -&gt; None\n</code></pre> <p>Initialize the dispatch handler.</p> PARAMETER DESCRIPTION <code>actor_factory</code> <p>A callable that creates an actor with some initial dispatch information.</p> <p> TYPE: <code>Callable[[DispatchInfo, Receiver[DispatchInfo]], Actor]</code> </p> <code>running_status_receiver</code> <p>The receiver for dispatch running status changes.</p> <p> TYPE: <code>Receiver[Dispatch]</code> </p> Source code in <code>frequenz/dispatch/_actor_dispatcher.py</code> <pre><code>def __init__(\n    self,\n    actor_factory: Callable[[DispatchInfo, Receiver[DispatchInfo]], Actor],\n    running_status_receiver: Receiver[Dispatch],\n) -&gt; None:\n    \"\"\"Initialize the dispatch handler.\n\n    Args:\n        actor_factory: A callable that creates an actor with some initial dispatch\n            information.\n        running_status_receiver: The receiver for dispatch running status changes.\n    \"\"\"\n    super().__init__()\n    self._dispatch_rx = running_status_receiver\n    self._actor_factory = actor_factory\n    self._actor: Actor | None = None\n    self._updates_channel = Broadcast[DispatchInfo](\n        name=\"dispatch_updates_channel\", resend_latest=True\n    )\n    self._updates_sender = self._updates_channel.new_sender()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the background service.</p> Source code in <code>frequenz/dispatch/_actor_dispatcher.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the background service.\"\"\"\n    self._tasks.add(asyncio.create_task(self._run()))\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:  # noqa: DOC503\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ActorDispatcher.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created","title":"frequenz.dispatch.Created  <code>dataclass</code>","text":"<p>A dispatch created event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Created:\n    \"\"\"A dispatch created event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was created.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was created.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted","title":"frequenz.dispatch.Deleted  <code>dataclass</code>","text":"<p>A dispatch deleted event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Deleted:\n    \"\"\"A dispatch deleted event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was deleted.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was deleted.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch","title":"frequenz.dispatch.Dispatch  <code>dataclass</code>","text":"<p>               Bases: <code>Dispatch</code></p> <p>Dispatch type with extra functionality.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>@dataclass(frozen=True)\nclass Dispatch(BaseDispatch):\n    \"\"\"Dispatch type with extra functionality.\"\"\"\n\n    deleted: bool = False\n    \"\"\"Whether the dispatch is deleted.\"\"\"\n\n    def __init__(\n        self,\n        client_dispatch: BaseDispatch,\n        deleted: bool = False,\n    ):\n        \"\"\"Initialize the dispatch.\n\n        Args:\n            client_dispatch: The client dispatch.\n            deleted: Whether the dispatch is deleted.\n        \"\"\"\n        super().__init__(**client_dispatch.__dict__)\n        # Work around frozen to set deleted\n        object.__setattr__(self, \"deleted\", deleted)\n\n    def _set_deleted(self) -&gt; None:\n        \"\"\"Mark the dispatch as deleted.\"\"\"\n        object.__setattr__(self, \"deleted\", True)\n\n    @property\n    def started(self) -&gt; bool:\n        \"\"\"Check if the dispatch is started.\n\n        Returns:\n            True if the dispatch is started, False otherwise.\n        \"\"\"\n        if self.deleted:\n            return False\n\n        return super().started\n\n    # noqa is needed because of a bug in pydoclint that makes it think a `return` without a return\n    # value needs documenting\n    def missed_runs(self, since: datetime) -&gt; Iterator[datetime]:  # noqa: DOC405\n        \"\"\"Yield all missed runs of a dispatch.\n\n        Yields all missed runs of a dispatch.\n\n        Args:\n            since: The time to start checking for missed runs.\n\n        Returns:\n            A generator that yields all missed runs of a dispatch.\n\n        Yields:\n            datetime: The missed run.\n        \"\"\"\n        now = datetime.now(tz=timezone.utc)\n\n        while (next_run := self.next_run_after(since)) and next_run &lt; now:\n            yield next_run\n            since = next_run\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.active","title":"active  <code>instance-attribute</code>","text":"<pre><code>active: bool\n</code></pre> <p>Indicates whether the dispatch is active and eligible for processing.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.create_time","title":"create_time  <code>instance-attribute</code>","text":"<pre><code>create_time: datetime\n</code></pre> <p>The creation time of the dispatch in UTC. Set when a dispatch is created.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.deleted","title":"deleted  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deleted: bool = False\n</code></pre> <p>Whether the dispatch is deleted.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Indicates if the dispatch is a dry run.</p> <p>Executed for logging and monitoring without affecting actual component states.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: timedelta | None\n</code></pre> <p>The duration of the dispatch, represented as a timedelta.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique identifier for the dispatch.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.next_run","title":"next_run  <code>property</code>","text":"<pre><code>next_run: datetime | None\n</code></pre> <p>Calculate the next run of a dispatch.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The next run of the dispatch or None if the dispatch is finished.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Any]\n</code></pre> <p>The dispatch payload containing arbitrary data.</p> <p>It is structured as needed for the dispatch operation.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.recurrence","title":"recurrence  <code>instance-attribute</code>","text":"<pre><code>recurrence: RecurrenceRule\n</code></pre> <p>The recurrence rule for the dispatch.</p> <p>Defining any repeating patterns or schedules.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime\n</code></pre> <p>The start time of the dispatch in UTC.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.started","title":"started  <code>property</code>","text":"<pre><code>started: bool\n</code></pre> <p>Check if the dispatch is started.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the dispatch is started, False otherwise.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: TargetComponents\n</code></pre> <p>The target components of the dispatch.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>User-defined information about the type of dispatch.</p> <p>This is understood and processed by downstream applications.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.until","title":"until  <code>property</code>","text":"<pre><code>until: datetime | None\n</code></pre> <p>Time when the dispatch should end.</p> <p>Returns the time that a running dispatch should end. If the dispatch is not running, None is returned.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The time when the dispatch should end or None if the dispatch is not running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.update_time","title":"update_time  <code>instance-attribute</code>","text":"<pre><code>update_time: datetime\n</code></pre> <p>The last update time of the dispatch in UTC. Set when a dispatch is modified.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.__init__","title":"__init__","text":"<pre><code>__init__(client_dispatch: Dispatch, deleted: bool = False)\n</code></pre> <p>Initialize the dispatch.</p> PARAMETER DESCRIPTION <code>client_dispatch</code> <p>The client dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> <code>deleted</code> <p>Whether the dispatch is deleted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def __init__(\n    self,\n    client_dispatch: BaseDispatch,\n    deleted: bool = False,\n):\n    \"\"\"Initialize the dispatch.\n\n    Args:\n        client_dispatch: The client dispatch.\n        deleted: Whether the dispatch is deleted.\n    \"\"\"\n    super().__init__(**client_dispatch.__dict__)\n    # Work around frozen to set deleted\n    object.__setattr__(self, \"deleted\", deleted)\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_object: Dispatch) -&gt; Dispatch\n</code></pre> <p>Convert a protobuf dispatch to a dispatch.</p> PARAMETER DESCRIPTION <code>pb_object</code> <p>The protobuf dispatch to convert.</p> <p> TYPE: <code>Dispatch</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_object: PBDispatch) -&gt; \"Dispatch\":\n    \"\"\"Convert a protobuf dispatch to a dispatch.\n\n    Args:\n        pb_object: The protobuf dispatch to convert.\n\n    Returns:\n        The converted dispatch.\n    \"\"\"\n    return Dispatch(\n        id=pb_object.metadata.dispatch_id,\n        type=pb_object.data.type,\n        create_time=to_datetime(pb_object.metadata.create_time),\n        update_time=to_datetime(pb_object.metadata.modification_time),\n        start_time=to_datetime(pb_object.data.start_time),\n        duration=(\n            timedelta(seconds=pb_object.data.duration)\n            if pb_object.data.HasField(\"duration\")\n            else None\n        ),\n        target=_target_components_from_protobuf(pb_object.data.target),\n        active=pb_object.data.is_active,\n        dry_run=pb_object.data.is_dry_run,\n        payload=MessageToDict(pb_object.data.payload),\n        recurrence=RecurrenceRule.from_protobuf(pb_object.data.recurrence),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.missed_runs","title":"missed_runs","text":"<pre><code>missed_runs(since: datetime) -&gt; Iterator[datetime]\n</code></pre> <p>Yield all missed runs of a dispatch.</p> <p>Yields all missed runs of a dispatch.</p> PARAMETER DESCRIPTION <code>since</code> <p>The time to start checking for missed runs.</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>Iterator[datetime]</code> <p>A generator that yields all missed runs of a dispatch.</p> YIELDS DESCRIPTION <code>datetime</code> <p>The missed run.</p> <p> TYPE:: <code>datetime</code> </p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def missed_runs(self, since: datetime) -&gt; Iterator[datetime]:  # noqa: DOC405\n    \"\"\"Yield all missed runs of a dispatch.\n\n    Yields all missed runs of a dispatch.\n\n    Args:\n        since: The time to start checking for missed runs.\n\n    Returns:\n        A generator that yields all missed runs of a dispatch.\n\n    Yields:\n        datetime: The missed run.\n    \"\"\"\n    now = datetime.now(tz=timezone.utc)\n\n    while (next_run := self.next_run_after(since)) and next_run &lt; now:\n        yield next_run\n        since = next_run\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.next_run_after","title":"next_run_after","text":"<pre><code>next_run_after(after: datetime) -&gt; datetime | None\n</code></pre> <p>Calculate the next run of a dispatch.</p> PARAMETER DESCRIPTION <code>after</code> <p>The time to calculate the next run from.</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The next run of the dispatch or None if the dispatch is finished.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def next_run_after(self, after: datetime) -&gt; datetime | None:\n    \"\"\"Calculate the next run of a dispatch.\n\n    Args:\n        after: The time to calculate the next run from.\n\n    Returns:\n        The next run of the dispatch or None if the dispatch is finished.\n    \"\"\"\n    if (\n        not self.recurrence.frequency\n        or self.recurrence.frequency == Frequency.UNSPECIFIED\n        or self.duration is None  # Infinite duration\n    ):\n        if after &gt; self.start_time:\n            return None\n        return self.start_time\n\n    # Make sure no weekday is UNSPECIFIED\n    if Weekday.UNSPECIFIED in self.recurrence.byweekdays:\n        return None\n\n    # No type information for rrule, so we need to cast\n    return cast(\n        datetime | None,\n        self.recurrence._as_rrule(  # pylint: disable=protected-access\n            self.start_time\n        ).after(after, inc=True),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; Dispatch\n</code></pre> <p>Convert a dispatch to a protobuf dispatch.</p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted protobuf dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBDispatch:\n    \"\"\"Convert a dispatch to a protobuf dispatch.\n\n    Returns:\n        The converted protobuf dispatch.\n    \"\"\"\n    payload = Struct()\n    payload.update(self.payload)\n\n    return PBDispatch(\n        metadata=DispatchMetadata(\n            dispatch_id=self.id,\n            create_time=to_timestamp(self.create_time),\n            modification_time=to_timestamp(self.update_time),\n        ),\n        data=DispatchData(\n            type=self.type,\n            start_time=to_timestamp(self.start_time),\n            duration=(\n                None\n                if self.duration is None\n                else round(self.duration.total_seconds())\n            ),\n            target=_target_components_to_protobuf(self.target),\n            is_active=self.active,\n            is_dry_run=self.dry_run,\n            payload=payload,\n            recurrence=self.recurrence.to_protobuf() if self.recurrence else None,\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchInfo","title":"frequenz.dispatch.DispatchInfo  <code>dataclass</code>","text":"<p>Event emitted when the dispatch changes.</p> Source code in <code>frequenz/dispatch/_actor_dispatcher.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DispatchInfo:\n    \"\"\"Event emitted when the dispatch changes.\"\"\"\n\n    components: TargetComponents\n    \"\"\"Components to be used.\"\"\"\n\n    dry_run: bool\n    \"\"\"Whether this is a dry run.\"\"\"\n\n    options: dict[str, Any]\n    \"\"\"Additional options.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchInfo-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchInfo.components","title":"components  <code>instance-attribute</code>","text":"<pre><code>components: TargetComponents\n</code></pre> <p>Components to be used.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchInfo.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Whether this is a dry run.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchInfo.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>Additional options.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher","title":"frequenz.dispatch.Dispatcher","text":"<p>A highlevel interface for the dispatch API.</p> <p>This class provides a highlevel interface to the dispatch API. It provides two channels:</p> Lifecycle events <p>A channel that sends a dispatch event message whenever a dispatch is created, updated or deleted.</p> Running status change <p>Sends a dispatch message whenever a dispatch is ready to be executed according to the schedule or the running status of the dispatch changed in a way that could potentially require the consumer to start, stop or reconfigure itself.</p> Processing running state change dispatches <pre><code>import os\nfrom frequenz.dispatch import Dispatcher\nfrom unittest.mock import MagicMock\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()\n\n    actor = MagicMock() # replace with your actor\n\n    changed_running_status = dispatcher.new_running_state_event_receiver(\"DISPATCH_TYPE\")\n\n    async for dispatch in changed_running_status:\n        if dispatch.started:\n            print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n            if actor.is_running:\n                actor.reconfigure(\n                    components=dispatch.target,\n                    run_parameters=dispatch.payload, # custom actor parameters\n                    dry_run=dispatch.dry_run,\n                    until=dispatch.until,\n                )  # this will reconfigure the actor\n            else:\n                # this will start a new actor with the given components\n                # and run it for the duration of the dispatch\n                actor.start(\n                    components=dispatch.target,\n                    run_parameters=dispatch.payload, # custom actor parameters\n                    dry_run=dispatch.dry_run,\n                    until=dispatch.until,\n                )\n        else:\n            actor.stop()  # this will stop the actor\n</code></pre> Getting notification about dispatch lifecycle events <pre><code>import os\nfrom typing import assert_never\n\nfrom frequenz.dispatch import Created, Deleted, Dispatcher, Updated\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()  # this will start the actor\n\n    events_receiver = dispatcher.new_lifecycle_events_receiver(\"DISPATCH_TYPE\")\n\n    async for event in events_receiver:\n        match event:\n            case Created(dispatch):\n                print(f\"A dispatch was created: {dispatch}\")\n            case Deleted(dispatch):\n                print(f\"A dispatch was deleted: {dispatch}\")\n            case Updated(dispatch):\n                print(f\"A dispatch was updated: {dispatch}\")\n            case _ as unhandled:\n                assert_never(unhandled)\n</code></pre> Creating a new dispatch and then modifying it. <p>Note that this uses the lower-level <code>Client</code> class to create and update the dispatch.</p> <pre><code>import os\nfrom datetime import datetime, timedelta, timezone\n\nfrom frequenz.client.common.microgrid.components import ComponentCategory\n\nfrom frequenz.dispatch import Dispatcher\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()  # this will start the actor\n\n    # Create a new dispatch\n    new_dispatch = await dispatcher.client.create(\n        microgrid_id=microgrid_id,\n        type=\"ECHO_FREQUENCY\",  # replace with your own type\n        start_time=datetime.now(tz=timezone.utc) + timedelta(minutes=10),\n        duration=timedelta(minutes=5),\n        target=ComponentCategory.INVERTER,\n        payload={\"font\": \"Times New Roman\"},  # Arbitrary payload data\n    )\n\n    # Modify the dispatch\n    await dispatcher.client.update(\n        microgrid_id=microgrid_id,\n        dispatch_id=new_dispatch.id,\n        new_fields={\"duration\": timedelta(minutes=10)}\n    )\n\n    # Validate the modification\n    modified_dispatch = await dispatcher.client.get(\n        microgrid_id=microgrid_id, dispatch_id=new_dispatch.id\n    )\n    assert modified_dispatch.duration == timedelta(minutes=10)\n</code></pre> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>class Dispatcher:\n    \"\"\"A highlevel interface for the dispatch API.\n\n    This class provides a highlevel interface to the dispatch API.\n    It provides two channels:\n\n    Lifecycle events:\n        A channel that sends a dispatch event message whenever a dispatch\n        is created, updated or deleted.\n\n    Running status change:\n        Sends a dispatch message whenever a dispatch is ready\n        to be executed according to the schedule or the running status of the\n        dispatch changed in a way that could potentially require the consumer to start,\n        stop or reconfigure itself.\n\n    Example: Processing running state change dispatches\n        ```python\n        import os\n        from frequenz.dispatch import Dispatcher\n        from unittest.mock import MagicMock\n\n        async def run():\n            url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                server_url=url,\n                key=key\n            )\n            await dispatcher.start()\n\n            actor = MagicMock() # replace with your actor\n\n            changed_running_status = dispatcher.new_running_state_event_receiver(\"DISPATCH_TYPE\")\n\n            async for dispatch in changed_running_status:\n                if dispatch.started:\n                    print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                    if actor.is_running:\n                        actor.reconfigure(\n                            components=dispatch.target,\n                            run_parameters=dispatch.payload, # custom actor parameters\n                            dry_run=dispatch.dry_run,\n                            until=dispatch.until,\n                        )  # this will reconfigure the actor\n                    else:\n                        # this will start a new actor with the given components\n                        # and run it for the duration of the dispatch\n                        actor.start(\n                            components=dispatch.target,\n                            run_parameters=dispatch.payload, # custom actor parameters\n                            dry_run=dispatch.dry_run,\n                            until=dispatch.until,\n                        )\n                else:\n                    actor.stop()  # this will stop the actor\n        ```\n\n    Example: Getting notification about dispatch lifecycle events\n        ```python\n        import os\n        from typing import assert_never\n\n        from frequenz.dispatch import Created, Deleted, Dispatcher, Updated\n\n        async def run():\n            url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                server_url=url,\n                key=key\n            )\n            await dispatcher.start()  # this will start the actor\n\n            events_receiver = dispatcher.new_lifecycle_events_receiver(\"DISPATCH_TYPE\")\n\n            async for event in events_receiver:\n                match event:\n                    case Created(dispatch):\n                        print(f\"A dispatch was created: {dispatch}\")\n                    case Deleted(dispatch):\n                        print(f\"A dispatch was deleted: {dispatch}\")\n                    case Updated(dispatch):\n                        print(f\"A dispatch was updated: {dispatch}\")\n                    case _ as unhandled:\n                        assert_never(unhandled)\n        ```\n\n    Example: Creating a new dispatch and then modifying it.\n        Note that this uses the lower-level `Client` class to create and update the dispatch.\n\n        ```python\n        import os\n        from datetime import datetime, timedelta, timezone\n\n        from frequenz.client.common.microgrid.components import ComponentCategory\n\n        from frequenz.dispatch import Dispatcher\n\n        async def run():\n            url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                server_url=url,\n                key=key\n            )\n            await dispatcher.start()  # this will start the actor\n\n            # Create a new dispatch\n            new_dispatch = await dispatcher.client.create(\n                microgrid_id=microgrid_id,\n                type=\"ECHO_FREQUENCY\",  # replace with your own type\n                start_time=datetime.now(tz=timezone.utc) + timedelta(minutes=10),\n                duration=timedelta(minutes=5),\n                target=ComponentCategory.INVERTER,\n                payload={\"font\": \"Times New Roman\"},  # Arbitrary payload data\n            )\n\n            # Modify the dispatch\n            await dispatcher.client.update(\n                microgrid_id=microgrid_id,\n                dispatch_id=new_dispatch.id,\n                new_fields={\"duration\": timedelta(minutes=10)}\n            )\n\n            # Validate the modification\n            modified_dispatch = await dispatcher.client.get(\n                microgrid_id=microgrid_id, dispatch_id=new_dispatch.id\n            )\n            assert modified_dispatch.duration == timedelta(minutes=10)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        microgrid_id: int,\n        server_url: str,\n        key: str,\n    ):\n        \"\"\"Initialize the dispatcher.\n\n        Args:\n            microgrid_id: The microgrid id.\n            server_url: The URL of the dispatch service.\n            key: The key to access the service.\n        \"\"\"\n        self._client = Client(server_url=server_url, key=key)\n        self._bg_service = DispatchScheduler(\n            microgrid_id,\n            self._client,\n        )\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the local dispatch service.\"\"\"\n        self._bg_service.start()\n\n    @property\n    def client(self) -&gt; Client:\n        \"\"\"Return the client.\"\"\"\n        return self._client\n\n    def new_lifecycle_events_receiver(\n        self, dispatch_type: str\n    ) -&gt; Receiver[DispatchEvent]:\n        \"\"\"Return new, updated or deleted dispatches receiver.\n\n        Args:\n            dispatch_type: The type of the dispatch to listen for.\n\n        Returns:\n            A new receiver for new dispatches.\n        \"\"\"\n        return self._bg_service.new_lifecycle_events_receiver(dispatch_type)\n\n    async def new_running_state_event_receiver(\n        self, dispatch_type: str, *, unify_running_intervals: bool = True\n    ) -&gt; Receiver[Dispatch]:\n        \"\"\"Return running state event receiver.\n\n        This receiver will receive a message whenever the current running\n        status of a dispatch changes.\n\n        Usually, one message per scheduled run is to be expected.\n        However, things get complicated when a dispatch was modified:\n\n        If it was currently running and the modification now says\n        it should not be running or running with different parameters,\n        then a message will be sent.\n\n        In other words: Any change that is expected to make an actor start, stop\n        or adjust itself according to new dispatch options causes a message to be\n        sent.\n\n        A non-exhaustive list of possible changes that will cause a message to be sent:\n         - The normal scheduled start_time has been reached\n         - The duration of the dispatch has been modified\n         - The start_time has been modified to be in the future\n         - The component selection changed\n         - The active status changed\n         - The dry_run status changed\n         - The payload changed\n         - The dispatch was deleted\n\n        If `unify_running_intervals` is True, running intervals from multiple\n        dispatches of the same type are considered as one continuous running\n        period. In this mode, any stop events are ignored as long as at least\n        one dispatch remains active.\n\n        Args:\n            dispatch_type: The type of the dispatch to listen for.\n            unify_running_intervals: Whether to unify running intervals.\n\n        Returns:\n            A new receiver for dispatches whose running status changed.\n        \"\"\"\n        return await self._bg_service.new_running_state_event_receiver(\n            dispatch_type, unify_running_intervals=unify_running_intervals\n        )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.client","title":"client  <code>property</code>","text":"<pre><code>client: Client\n</code></pre> <p>Return the client.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.__init__","title":"__init__","text":"<pre><code>__init__(*, microgrid_id: int, server_url: str, key: str)\n</code></pre> <p>Initialize the dispatcher.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid id.</p> <p> TYPE: <code>int</code> </p> <code>server_url</code> <p>The URL of the dispatch service.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key to access the service.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>def __init__(\n    self,\n    *,\n    microgrid_id: int,\n    server_url: str,\n    key: str,\n):\n    \"\"\"Initialize the dispatcher.\n\n    Args:\n        microgrid_id: The microgrid id.\n        server_url: The URL of the dispatch service.\n        key: The key to access the service.\n    \"\"\"\n    self._client = Client(server_url=server_url, key=key)\n    self._bg_service = DispatchScheduler(\n        microgrid_id,\n        self._client,\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.new_lifecycle_events_receiver","title":"new_lifecycle_events_receiver","text":"<pre><code>new_lifecycle_events_receiver(\n    dispatch_type: str,\n) -&gt; Receiver[DispatchEvent]\n</code></pre> <p>Return new, updated or deleted dispatches receiver.</p> PARAMETER DESCRIPTION <code>dispatch_type</code> <p>The type of the dispatch to listen for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Receiver[DispatchEvent]</code> <p>A new receiver for new dispatches.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>def new_lifecycle_events_receiver(\n    self, dispatch_type: str\n) -&gt; Receiver[DispatchEvent]:\n    \"\"\"Return new, updated or deleted dispatches receiver.\n\n    Args:\n        dispatch_type: The type of the dispatch to listen for.\n\n    Returns:\n        A new receiver for new dispatches.\n    \"\"\"\n    return self._bg_service.new_lifecycle_events_receiver(dispatch_type)\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.new_running_state_event_receiver","title":"new_running_state_event_receiver  <code>async</code>","text":"<pre><code>new_running_state_event_receiver(\n    dispatch_type: str,\n    *,\n    unify_running_intervals: bool = True\n) -&gt; Receiver[Dispatch]\n</code></pre> <p>Return running state event receiver.</p> <p>This receiver will receive a message whenever the current running status of a dispatch changes.</p> <p>Usually, one message per scheduled run is to be expected. However, things get complicated when a dispatch was modified:</p> <p>If it was currently running and the modification now says it should not be running or running with different parameters, then a message will be sent.</p> <p>In other words: Any change that is expected to make an actor start, stop or adjust itself according to new dispatch options causes a message to be sent.</p> A non-exhaustive list of possible changes that will cause a message to be sent <ul> <li>The normal scheduled start_time has been reached</li> <li>The duration of the dispatch has been modified</li> <li>The start_time has been modified to be in the future</li> <li>The component selection changed</li> <li>The active status changed</li> <li>The dry_run status changed</li> <li>The payload changed</li> <li>The dispatch was deleted</li> </ul> <p>If <code>unify_running_intervals</code> is True, running intervals from multiple dispatches of the same type are considered as one continuous running period. In this mode, any stop events are ignored as long as at least one dispatch remains active.</p> PARAMETER DESCRIPTION <code>dispatch_type</code> <p>The type of the dispatch to listen for.</p> <p> TYPE: <code>str</code> </p> <code>unify_running_intervals</code> <p>Whether to unify running intervals.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Receiver[Dispatch]</code> <p>A new receiver for dispatches whose running status changed.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>async def new_running_state_event_receiver(\n    self, dispatch_type: str, *, unify_running_intervals: bool = True\n) -&gt; Receiver[Dispatch]:\n    \"\"\"Return running state event receiver.\n\n    This receiver will receive a message whenever the current running\n    status of a dispatch changes.\n\n    Usually, one message per scheduled run is to be expected.\n    However, things get complicated when a dispatch was modified:\n\n    If it was currently running and the modification now says\n    it should not be running or running with different parameters,\n    then a message will be sent.\n\n    In other words: Any change that is expected to make an actor start, stop\n    or adjust itself according to new dispatch options causes a message to be\n    sent.\n\n    A non-exhaustive list of possible changes that will cause a message to be sent:\n     - The normal scheduled start_time has been reached\n     - The duration of the dispatch has been modified\n     - The start_time has been modified to be in the future\n     - The component selection changed\n     - The active status changed\n     - The dry_run status changed\n     - The payload changed\n     - The dispatch was deleted\n\n    If `unify_running_intervals` is True, running intervals from multiple\n    dispatches of the same type are considered as one continuous running\n    period. In this mode, any stop events are ignored as long as at least\n    one dispatch remains active.\n\n    Args:\n        dispatch_type: The type of the dispatch to listen for.\n        unify_running_intervals: Whether to unify running intervals.\n\n    Returns:\n        A new receiver for dispatches whose running status changed.\n    \"\"\"\n    return await self._bg_service.new_running_state_event_receiver(\n        dispatch_type, unify_running_intervals=unify_running_intervals\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the local dispatch service.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the local dispatch service.\"\"\"\n    self._bg_service.start()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated","title":"frequenz.dispatch.Updated  <code>dataclass</code>","text":"<p>A dispatch updated event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Updated:\n    \"\"\"A dispatch updated event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was updated.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was updated.</p>"}]}