{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Highlevel Interface","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A highlevel interface for the dispatch API.</p> <p>See the documentation for more information.</p>"},{"location":"#usage","title":"Usage","text":"<p>The <code>Dispatcher</code> class, the main entry point for the API, provides two channels:</p> <ul> <li>Lifecycle events: A channel that sends a message whenever a Dispatch is created, updated or deleted.</li> <li>Running status change: Sends a dispatch message whenever a dispatch is ready to be executed according to the schedule or the running status of the dispatch changed in a way that could potentially require the actor to start, stop or reconfigure itself.</li> </ul>"},{"location":"#example-using-the-running-status-change-channel","title":"Example using the running status change channel","text":"<pre><code>import os\nimport grpc.aio\nfrom unittest.mock import MagicMock\n\nasync def run():\n    host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n    port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n\n    service_address = f\"{host}:{port}\"\n    grpc_channel = grpc.aio.insecure_channel(service_address)\n    microgrid_id = 1\n    dispatcher = Dispatcher(microgrid_id, grpc_channel, service_address)\n    await dispatcher.start()\n\n    actor = MagicMock() # replace with your actor\n\n    changed_running_status_rx = dispatcher.running_status_change.new_receiver()\n\n    async for dispatch in changed_running_status_rx:\n        match dispatch.running(\"DEMO_TYPE\"):\n            case RunningState.RUNNING:\n                print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                if actor.is_running:\n                    actor.reconfigure(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )  # this will reconfigure the actor\n                else:\n                    # this will start a new actor with the given components\n                    # and run it for the duration of the dispatch\n                    actor.start(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )\n            case RunningState.STOPPED:\n                actor.stop()  # this will stop the actor\n            case RunningState.DIFFERENT_TYPE:\n                pass  # dispatch not for this type\n</code></pre>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Dispatch Highlevel Interface","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>dispatch<ul> <li>actor</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/dispatch/","title":"Index","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch","title":"frequenz.dispatch","text":"<p>A highlevel interface for the dispatch API.</p> <p>A small overview of the most important classes in this module:</p> <ul> <li>Dispatcher: The entry point for the API.</li> <li>Dispatch: A dispatch type with lots of useful extra functionality.</li> <li>Created,   Updated,   Deleted: Dispatch event types.</li> </ul>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchEvent","title":"frequenz.dispatch.DispatchEvent  <code>module-attribute</code>","text":"<pre><code>DispatchEvent = Created | Updated | Deleted\n</code></pre> <p>Type that is sent over the channel for dispatch updates.</p> <p>This type is used to send dispatches that were created, updated or deleted over the channel.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch-classes","title":"Classes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created","title":"frequenz.dispatch.Created  <code>dataclass</code>","text":"<p>A dispatch created event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Created:\n    \"\"\"A dispatch created event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was created.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was created.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted","title":"frequenz.dispatch.Deleted  <code>dataclass</code>","text":"<p>A dispatch deleted event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Deleted:\n    \"\"\"A dispatch deleted event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was deleted.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was deleted.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch","title":"frequenz.dispatch.Dispatch  <code>dataclass</code>","text":"<p>               Bases: <code>Dispatch</code></p> <p>Dispatch type with extra functionality.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>@dataclass(frozen=True)\nclass Dispatch(BaseDispatch):\n    \"\"\"Dispatch type with extra functionality.\"\"\"\n\n    deleted: bool = False\n    \"\"\"Whether the dispatch is deleted.\"\"\"\n\n    running_state_change_synced: datetime | None = None\n    \"\"\"The last time a message was sent about the running state change.\"\"\"\n\n    def __init__(\n        self,\n        client_dispatch: BaseDispatch,\n        deleted: bool = False,\n        running_state_change_synced: datetime | None = None,\n    ):\n        \"\"\"Initialize the dispatch.\n\n        Args:\n            client_dispatch: The client dispatch.\n            deleted: Whether the dispatch is deleted.\n            running_state_change_synced: Timestamp of the last running state change message.\n        \"\"\"\n        super().__init__(**client_dispatch.__dict__)\n        # Work around frozen to set deleted\n        object.__setattr__(self, \"deleted\", deleted)\n        object.__setattr__(\n            self,\n            \"running_state_change_synced\",\n            running_state_change_synced,\n        )\n\n    def _set_deleted(self) -&gt; None:\n        \"\"\"Mark the dispatch as deleted.\"\"\"\n        object.__setattr__(self, \"deleted\", True)\n\n    @property\n    def _running_status_notified(self) -&gt; bool:\n        \"\"\"Check that the latest running state change notification was sent.\n\n        Returns:\n            True if the latest running state change notification was sent, False otherwise.\n        \"\"\"\n        return self.running_state_change_synced == self.update_time\n\n    def _set_running_status_notified(self) -&gt; None:\n        \"\"\"Mark the latest running state change notification as sent.\"\"\"\n        object.__setattr__(self, \"running_state_change_synced\", self.update_time)\n\n    def running(self, type_: str) -&gt; RunningState:\n        \"\"\"Check if the dispatch is currently supposed to be running.\n\n        Args:\n            type_: The type of the dispatch that should be running.\n\n        Returns:\n            RUNNING if the dispatch is running,\n            STOPPED if it is stopped,\n            DIFFERENT_TYPE if it is for a different type.\n        \"\"\"\n        if self.type != type_:\n            return RunningState.DIFFERENT_TYPE\n\n        if not self.active or self.deleted:\n            return RunningState.STOPPED\n\n        now = datetime.now(tz=timezone.utc)\n        if until := self._until(now):\n            return RunningState.RUNNING if now &lt; until else RunningState.STOPPED\n\n        return RunningState.STOPPED\n\n    @property\n    def until(self) -&gt; datetime | None:\n        \"\"\"Time when the dispatch should end.\n\n        Returns the time that a running dispatch should end.\n        If the dispatch is not running, None is returned.\n\n        Returns:\n            The time when the dispatch should end or None if the dispatch is not running.\n        \"\"\"\n        if not self.active or self.deleted:\n            return None\n\n        now = datetime.now(tz=timezone.utc)\n        return self._until(now)\n\n    @property\n    # noqa is needed because of a bug in pydoclint that makes it think a `return` without a return\n    # value needs documenting\n    def missed_runs(self) -&gt; Iterator[datetime]:  # noqa: DOC405\n        \"\"\"Yield all missed runs of a dispatch.\n\n        Yields all missed runs of a dispatch.\n\n        If a running state change notification was not sent in time\n        due to connection issues, this method will yield all missed runs\n        since the last sent notification.\n\n        Returns:\n            A generator that yields all missed runs of a dispatch.\n        \"\"\"\n        if self.update_time == self.running_state_change_synced:\n            return\n\n        from_time = self.update_time\n        now = datetime.now(tz=timezone.utc)\n\n        while (next_run := self.next_run_after(from_time)) and next_run &lt; now:\n            yield next_run\n            from_time = next_run\n\n    @property\n    def next_run(self) -&gt; datetime | None:\n        \"\"\"Calculate the next run of a dispatch.\n\n        Returns:\n            The next run of the dispatch or None if the dispatch is finished.\n        \"\"\"\n        return self.next_run_after(datetime.now(tz=timezone.utc))\n\n    def next_run_after(self, after: datetime) -&gt; datetime | None:\n        \"\"\"Calculate the next run of a dispatch.\n\n        Args:\n            after: The time to calculate the next run from.\n\n        Returns:\n            The next run of the dispatch or None if the dispatch is finished.\n        \"\"\"\n        if (\n            not self.recurrence.frequency\n            or self.recurrence.frequency == Frequency.UNSPECIFIED\n        ):\n            if after &gt; self.start_time:\n                return None\n            return self.start_time\n\n        # Make sure no weekday is UNSPECIFIED\n        if Weekday.UNSPECIFIED in self.recurrence.byweekdays:\n            _logger.warning(\"Dispatch %s has UNSPECIFIED weekday, ignoring...\", self.id)\n            return None\n\n        # No type information for rrule, so we need to cast\n        return cast(datetime | None, self._prepare_rrule().after(after, inc=True))\n\n    def _prepare_rrule(self) -&gt; rrule.rrule:\n        \"\"\"Prepare the rrule object.\n\n        Returns:\n            The rrule object.\n        \"\"\"\n        count, until = (None, None)\n        if end := self.recurrence.end_criteria:\n            count = end.count\n            until = end.until\n\n        rrule_obj = rrule.rrule(\n            freq=_RRULE_FREQ_MAP[self.recurrence.frequency],\n            dtstart=self.start_time,\n            count=count,\n            until=until,\n            byminute=self.recurrence.byminutes,\n            byhour=self.recurrence.byhours,\n            byweekday=[\n                _RRULE_WEEKDAY_MAP[weekday] for weekday in self.recurrence.byweekdays\n            ],\n            bymonthday=self.recurrence.bymonthdays,\n            bymonth=self.recurrence.bymonths,\n            interval=self.recurrence.interval,\n        )\n\n        return rrule_obj\n\n    def _until(self, now: datetime) -&gt; datetime | None:\n        \"\"\"Calculate the time when the dispatch should end.\n\n        If no previous run is found, None is returned.\n\n        Args:\n            now: The current time.\n\n        Returns:\n            The time when the dispatch should end or None if the dispatch is not running.\n        \"\"\"\n        if (\n            not self.recurrence.frequency\n            or self.recurrence.frequency == Frequency.UNSPECIFIED\n        ):\n            return self.start_time + self.duration\n\n        latest_past_start: datetime | None = self._prepare_rrule().before(now, inc=True)\n\n        if not latest_past_start:\n            return None\n\n        return latest_past_start + self.duration\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.active","title":"active  <code>instance-attribute</code>","text":"<pre><code>active: bool\n</code></pre> <p>Indicates whether the dispatch is active and eligible for processing.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.create_time","title":"create_time  <code>instance-attribute</code>","text":"<pre><code>create_time: datetime\n</code></pre> <p>The creation time of the dispatch in UTC. Set when a dispatch is created.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.deleted","title":"deleted  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deleted: bool = False\n</code></pre> <p>Whether the dispatch is deleted.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Indicates if the dispatch is a dry run.</p> <p>Executed for logging and monitoring without affecting actual component states.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: timedelta\n</code></pre> <p>The duration of the dispatch, represented as a timedelta.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique identifier for the dispatch.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.missed_runs","title":"missed_runs  <code>property</code>","text":"<pre><code>missed_runs: Iterator[datetime]\n</code></pre> <p>Yield all missed runs of a dispatch.</p> <p>Yields all missed runs of a dispatch.</p> <p>If a running state change notification was not sent in time due to connection issues, this method will yield all missed runs since the last sent notification.</p> RETURNS DESCRIPTION <code>Iterator[datetime]</code> <p>A generator that yields all missed runs of a dispatch.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.next_run","title":"next_run  <code>property</code>","text":"<pre><code>next_run: datetime | None\n</code></pre> <p>Calculate the next run of a dispatch.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The next run of the dispatch or None if the dispatch is finished.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Any]\n</code></pre> <p>The dispatch payload containing arbitrary data.</p> <p>It is structured as needed for the dispatch operation.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.recurrence","title":"recurrence  <code>instance-attribute</code>","text":"<pre><code>recurrence: RecurrenceRule\n</code></pre> <p>The recurrence rule for the dispatch.</p> <p>Defining any repeating patterns or schedules.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.running_state_change_synced","title":"running_state_change_synced  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>running_state_change_synced: datetime | None = None\n</code></pre> <p>The last time a message was sent about the running state change.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector: ComponentSelector\n</code></pre> <p>The component selector specifying which components the dispatch targets.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime\n</code></pre> <p>The start time of the dispatch in UTC.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>User-defined information about the type of dispatch.</p> <p>This is understood and processed by downstream applications.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.until","title":"until  <code>property</code>","text":"<pre><code>until: datetime | None\n</code></pre> <p>Time when the dispatch should end.</p> <p>Returns the time that a running dispatch should end. If the dispatch is not running, None is returned.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The time when the dispatch should end or None if the dispatch is not running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.update_time","title":"update_time  <code>instance-attribute</code>","text":"<pre><code>update_time: datetime\n</code></pre> <p>The last update time of the dispatch in UTC. Set when a dispatch is modified.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.__init__","title":"__init__","text":"<pre><code>__init__(\n    client_dispatch: Dispatch,\n    deleted: bool = False,\n    running_state_change_synced: datetime | None = None,\n)\n</code></pre> <p>Initialize the dispatch.</p> PARAMETER DESCRIPTION <code>client_dispatch</code> <p>The client dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> <code>deleted</code> <p>Whether the dispatch is deleted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>running_state_change_synced</code> <p>Timestamp of the last running state change message.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def __init__(\n    self,\n    client_dispatch: BaseDispatch,\n    deleted: bool = False,\n    running_state_change_synced: datetime | None = None,\n):\n    \"\"\"Initialize the dispatch.\n\n    Args:\n        client_dispatch: The client dispatch.\n        deleted: Whether the dispatch is deleted.\n        running_state_change_synced: Timestamp of the last running state change message.\n    \"\"\"\n    super().__init__(**client_dispatch.__dict__)\n    # Work around frozen to set deleted\n    object.__setattr__(self, \"deleted\", deleted)\n    object.__setattr__(\n        self,\n        \"running_state_change_synced\",\n        running_state_change_synced,\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_object: DispatchDetail) -&gt; Dispatch\n</code></pre> <p>Convert a protobuf dispatch to a dispatch.</p> PARAMETER DESCRIPTION <code>pb_object</code> <p>The protobuf dispatch to convert.</p> <p> TYPE: <code>DispatchDetail</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_object: PBDispatchDetail) -&gt; \"Dispatch\":\n    \"\"\"Convert a protobuf dispatch to a dispatch.\n\n    Args:\n        pb_object: The protobuf dispatch to convert.\n\n    Returns:\n        The converted dispatch.\n    \"\"\"\n    return Dispatch(\n        id=pb_object.dispatch_id,\n        type=pb_object.dispatch.type,\n        create_time=to_datetime(pb_object.create_time),\n        update_time=to_datetime(pb_object.modification_time),\n        start_time=to_datetime(pb_object.dispatch.start_time),\n        duration=timedelta(seconds=pb_object.dispatch.duration),\n        selector=component_selector_from_protobuf(pb_object.dispatch.selector),\n        active=pb_object.dispatch.is_active,\n        dry_run=pb_object.dispatch.is_dry_run,\n        payload=MessageToDict(pb_object.dispatch.payload),\n        recurrence=RecurrenceRule.from_protobuf(pb_object.dispatch.recurrence),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.next_run_after","title":"next_run_after","text":"<pre><code>next_run_after(after: datetime) -&gt; datetime | None\n</code></pre> <p>Calculate the next run of a dispatch.</p> PARAMETER DESCRIPTION <code>after</code> <p>The time to calculate the next run from.</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The next run of the dispatch or None if the dispatch is finished.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def next_run_after(self, after: datetime) -&gt; datetime | None:\n    \"\"\"Calculate the next run of a dispatch.\n\n    Args:\n        after: The time to calculate the next run from.\n\n    Returns:\n        The next run of the dispatch or None if the dispatch is finished.\n    \"\"\"\n    if (\n        not self.recurrence.frequency\n        or self.recurrence.frequency == Frequency.UNSPECIFIED\n    ):\n        if after &gt; self.start_time:\n            return None\n        return self.start_time\n\n    # Make sure no weekday is UNSPECIFIED\n    if Weekday.UNSPECIFIED in self.recurrence.byweekdays:\n        _logger.warning(\"Dispatch %s has UNSPECIFIED weekday, ignoring...\", self.id)\n        return None\n\n    # No type information for rrule, so we need to cast\n    return cast(datetime | None, self._prepare_rrule().after(after, inc=True))\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.running","title":"running","text":"<pre><code>running(type_: str) -&gt; RunningState\n</code></pre> <p>Check if the dispatch is currently supposed to be running.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the dispatch that should be running.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>RunningState</code> <p>RUNNING if the dispatch is running,</p> <code>RunningState</code> <p>STOPPED if it is stopped,</p> <code>RunningState</code> <p>DIFFERENT_TYPE if it is for a different type.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def running(self, type_: str) -&gt; RunningState:\n    \"\"\"Check if the dispatch is currently supposed to be running.\n\n    Args:\n        type_: The type of the dispatch that should be running.\n\n    Returns:\n        RUNNING if the dispatch is running,\n        STOPPED if it is stopped,\n        DIFFERENT_TYPE if it is for a different type.\n    \"\"\"\n    if self.type != type_:\n        return RunningState.DIFFERENT_TYPE\n\n    if not self.active or self.deleted:\n        return RunningState.STOPPED\n\n    now = datetime.now(tz=timezone.utc)\n    if until := self._until(now):\n        return RunningState.RUNNING if now &lt; until else RunningState.STOPPED\n\n    return RunningState.STOPPED\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; DispatchDetail\n</code></pre> <p>Convert a dispatch to a protobuf dispatch.</p> RETURNS DESCRIPTION <code>DispatchDetail</code> <p>The converted protobuf dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBDispatchDetail:\n    \"\"\"Convert a dispatch to a protobuf dispatch.\n\n    Returns:\n        The converted protobuf dispatch.\n    \"\"\"\n    pb_dispatch = PBDispatchDetail()\n\n    pb_dispatch.dispatch_id = self.id\n    pb_dispatch.dispatch.type = self.type\n    pb_dispatch.create_time.CopyFrom(to_timestamp(self.create_time))\n    pb_dispatch.modification_time.CopyFrom(to_timestamp(self.update_time))\n    pb_dispatch.dispatch.start_time.CopyFrom(to_timestamp(self.start_time))\n    pb_dispatch.dispatch.duration = int(self.duration.total_seconds())\n    pb_dispatch.dispatch.selector.CopyFrom(\n        component_selector_to_protobuf(self.selector)\n    )\n    pb_dispatch.dispatch.is_active = self.active\n    pb_dispatch.dispatch.is_dry_run = self.dry_run\n    pb_dispatch.dispatch.payload.update(self.payload)\n    pb_dispatch.dispatch.recurrence.CopyFrom(self.recurrence.to_protobuf())\n\n    return pb_dispatch\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher","title":"frequenz.dispatch.Dispatcher","text":"<p>A highlevel interface for the dispatch API.</p> <p>This class provides a highlevel interface to the dispatch API. It provides two channels:</p> Lifecycle events <p>A channel that sends a dispatch event message whenever a dispatch is created, updated or deleted.</p> Running status change <p>Sends a dispatch message whenever a dispatch is ready to be executed according to the schedule or the running status of the dispatch changed in a way that could potentially require the consumer to start, stop or reconfigure itself.</p> Processing running state change dispatches <pre><code>import os\nimport grpc.aio\nfrom frequenz.dispatch import Dispatcher, RunningState\nfrom unittest.mock import MagicMock\n\nasync def run():\n    host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n    port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    service_address = f\"{host}:{port}\"\n    grpc_channel = grpc.aio.secure_channel(\n        service_address,\n        credentials=grpc.ssl_channel_credentials()\n    )\n    dispatcher = Dispatcher(\n        microgrid_id=1,\n        grpc_channel=grpc_channel,\n        svc_addr=service_address,\n        key=key\n    )\n    await dispatcher.start()\n\n    actor = MagicMock() # replace with your actor\n\n    changed_running_status = dispatcher.running_status_change.new_receiver()\n\n    async for dispatch in changed_running_status:\n        match dispatch.running(\"DEMO_TYPE\"):\n            case RunningState.RUNNING:\n                print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                if actor.is_running:\n                    actor.reconfigure(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )  # this will reconfigure the actor\n                else:\n                    # this will start a new actor with the given components\n                    # and run it for the duration of the dispatch\n                    actor.start(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )\n            case RunningState.STOPPED:\n                actor.stop()  # this will stop the actor\n            case RunningState.DIFFERENT_TYPE:\n                pass  # dispatch not for this type\n</code></pre> Getting notification about dispatch lifecycle events <pre><code>import os\nfrom typing import assert_never\n\nimport grpc.aio\nfrom frequenz.dispatch import Created, Deleted, Dispatcher, Updated\n\nasync def run():\n    host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n    port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    service_address = f\"{host}:{port}\"\n    grpc_channel = grpc.aio.secure_channel(\n        service_address,\n        credentials=grpc.ssl_channel_credentials()\n    )\n    dispatcher = Dispatcher(\n        microgrid_id=1,\n        grpc_channel=grpc_channel,\n        svc_addr=service_address,\n        key=key\n    )\n    await dispatcher.start()  # this will start the actor\n\n    events_receiver = dispatcher.lifecycle_events.new_receiver()\n\n    async for event in events_receiver:\n        match event:\n            case Created(dispatch):\n                print(f\"A dispatch was created: {dispatch}\")\n            case Deleted(dispatch):\n                print(f\"A dispatch was deleted: {dispatch}\")\n            case Updated(dispatch):\n                print(f\"A dispatch was updated: {dispatch}\")\n            case _ as unhandled:\n                assert_never(unhandled)\n</code></pre> Creating a new dispatch and then modifying it. <p>Note that this uses the lower-level <code>Client</code> class to create and update the dispatch.</p> <pre><code>import os\nfrom datetime import datetime, timedelta, timezone\n\nimport grpc.aio\nfrom frequenz.client.common.microgrid.components import ComponentCategory\n\nfrom frequenz.dispatch import Dispatcher\n\nasync def run():\n    host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n    port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    service_address = f\"{host}:{port}\"\n    grpc_channel = grpc.aio.secure_channel(\n        service_address,\n        credentials=grpc.ssl_channel_credentials()\n    )\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        grpc_channel=grpc_channel,\n        svc_addr=service_address,\n        key=key\n    )\n    await dispatcher.start()  # this will start the actor\n\n    # Create a new dispatch\n    new_dispatch = await dispatcher.client.create(\n        microgrid_id=microgrid_id,\n        type=\"ECHO_FREQUENCY\",  # replace with your own type\n        start_time=datetime.now(tz=timezone.utc) + timedelta(minutes=10),\n        duration=timedelta(minutes=5),\n        selector=ComponentCategory.INVERTER,\n        payload={\"font\": \"Times New Roman\"},  # Arbitrary payload data\n    )\n\n    # Modify the dispatch\n    await dispatcher.client.update(\n        microgrid_id=microgrid_id,\n        dispatch_id=new_dispatch.id,\n        new_fields={\"duration\": timedelta(minutes=10)}\n    )\n\n    # Validate the modification\n    modified_dispatch = await dispatcher.client.get(\n        microgrid_id=microgrid_id, dispatch_id=new_dispatch.id\n    )\n    assert modified_dispatch.duration == timedelta(minutes=10)\n</code></pre> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>class Dispatcher:\n    \"\"\"A highlevel interface for the dispatch API.\n\n    This class provides a highlevel interface to the dispatch API.\n    It provides two channels:\n\n    Lifecycle events:\n        A channel that sends a dispatch event message whenever a dispatch\n        is created, updated or deleted.\n\n    Running status change:\n        Sends a dispatch message whenever a dispatch is ready\n        to be executed according to the schedule or the running status of the\n        dispatch changed in a way that could potentially require the consumer to start,\n        stop or reconfigure itself.\n\n    Example: Processing running state change dispatches\n        ```python\n        import os\n        import grpc.aio\n        from frequenz.dispatch import Dispatcher, RunningState\n        from unittest.mock import MagicMock\n\n        async def run():\n            host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n            port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            service_address = f\"{host}:{port}\"\n            grpc_channel = grpc.aio.secure_channel(\n                service_address,\n                credentials=grpc.ssl_channel_credentials()\n            )\n            dispatcher = Dispatcher(\n                microgrid_id=1,\n                grpc_channel=grpc_channel,\n                svc_addr=service_address,\n                key=key\n            )\n            await dispatcher.start()\n\n            actor = MagicMock() # replace with your actor\n\n            changed_running_status = dispatcher.running_status_change.new_receiver()\n\n            async for dispatch in changed_running_status:\n                match dispatch.running(\"DEMO_TYPE\"):\n                    case RunningState.RUNNING:\n                        print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                        if actor.is_running:\n                            actor.reconfigure(\n                                components=dispatch.selector,\n                                run_parameters=dispatch.payload, # custom actor parameters\n                                dry_run=dispatch.dry_run,\n                                until=dispatch.until,\n                            )  # this will reconfigure the actor\n                        else:\n                            # this will start a new actor with the given components\n                            # and run it for the duration of the dispatch\n                            actor.start(\n                                components=dispatch.selector,\n                                run_parameters=dispatch.payload, # custom actor parameters\n                                dry_run=dispatch.dry_run,\n                                until=dispatch.until,\n                            )\n                    case RunningState.STOPPED:\n                        actor.stop()  # this will stop the actor\n                    case RunningState.DIFFERENT_TYPE:\n                        pass  # dispatch not for this type\n        ```\n\n    Example: Getting notification about dispatch lifecycle events\n        ```python\n        import os\n        from typing import assert_never\n\n        import grpc.aio\n        from frequenz.dispatch import Created, Deleted, Dispatcher, Updated\n\n        async def run():\n            host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n            port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            service_address = f\"{host}:{port}\"\n            grpc_channel = grpc.aio.secure_channel(\n                service_address,\n                credentials=grpc.ssl_channel_credentials()\n            )\n            dispatcher = Dispatcher(\n                microgrid_id=1,\n                grpc_channel=grpc_channel,\n                svc_addr=service_address,\n                key=key\n            )\n            await dispatcher.start()  # this will start the actor\n\n            events_receiver = dispatcher.lifecycle_events.new_receiver()\n\n            async for event in events_receiver:\n                match event:\n                    case Created(dispatch):\n                        print(f\"A dispatch was created: {dispatch}\")\n                    case Deleted(dispatch):\n                        print(f\"A dispatch was deleted: {dispatch}\")\n                    case Updated(dispatch):\n                        print(f\"A dispatch was updated: {dispatch}\")\n                    case _ as unhandled:\n                        assert_never(unhandled)\n        ```\n\n    Example: Creating a new dispatch and then modifying it.\n        Note that this uses the lower-level `Client` class to create and update the dispatch.\n\n        ```python\n        import os\n        from datetime import datetime, timedelta, timezone\n\n        import grpc.aio\n        from frequenz.client.common.microgrid.components import ComponentCategory\n\n        from frequenz.dispatch import Dispatcher\n\n        async def run():\n            host = os.getenv(\"DISPATCH_API_HOST\", \"localhost\")\n            port = os.getenv(\"DISPATCH_API_PORT\", \"50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            service_address = f\"{host}:{port}\"\n            grpc_channel = grpc.aio.secure_channel(\n                service_address,\n                credentials=grpc.ssl_channel_credentials()\n            )\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                grpc_channel=grpc_channel,\n                svc_addr=service_address,\n                key=key\n            )\n            await dispatcher.start()  # this will start the actor\n\n            # Create a new dispatch\n            new_dispatch = await dispatcher.client.create(\n                microgrid_id=microgrid_id,\n                type=\"ECHO_FREQUENCY\",  # replace with your own type\n                start_time=datetime.now(tz=timezone.utc) + timedelta(minutes=10),\n                duration=timedelta(minutes=5),\n                selector=ComponentCategory.INVERTER,\n                payload={\"font\": \"Times New Roman\"},  # Arbitrary payload data\n            )\n\n            # Modify the dispatch\n            await dispatcher.client.update(\n                microgrid_id=microgrid_id,\n                dispatch_id=new_dispatch.id,\n                new_fields={\"duration\": timedelta(minutes=10)}\n            )\n\n            # Validate the modification\n            modified_dispatch = await dispatcher.client.get(\n                microgrid_id=microgrid_id, dispatch_id=new_dispatch.id\n            )\n            assert modified_dispatch.duration == timedelta(minutes=10)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        microgrid_id: int,\n        grpc_channel: grpc.aio.Channel,\n        svc_addr: str,\n        key: str,\n    ):\n        \"\"\"Initialize the dispatcher.\n\n        Args:\n            microgrid_id: The microgrid id.\n            grpc_channel: The gRPC channel.\n            svc_addr: The service address.\n            key: The key to access the service.\n        \"\"\"\n        self._running_state_channel = Broadcast[Dispatch](name=\"running_state_change\")\n        self._lifecycle_events_channel = Broadcast[DispatchEvent](\n            name=\"lifecycle_events\"\n        )\n        self._client = Client(grpc_channel=grpc_channel, svc_addr=svc_addr, key=key)\n        self._actor = DispatchingActor(\n            microgrid_id,\n            self._client,\n            self._lifecycle_events_channel.new_sender(),\n            self._running_state_channel.new_sender(),\n        )\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the actor.\"\"\"\n        self._actor.start()\n\n    @property\n    def client(self) -&gt; Client:\n        \"\"\"Return the client.\"\"\"\n        return self._client\n\n    @property\n    def lifecycle_events(self) -&gt; ReceiverFetcher[DispatchEvent]:\n        \"\"\"Return new, updated or deleted dispatches receiver fetcher.\n\n        Returns:\n            A new receiver for new dispatches.\n        \"\"\"\n        return self._lifecycle_events_channel\n\n    @property\n    def running_status_change(self) -&gt; ReceiverFetcher[Dispatch]:\n        \"\"\"Return running status change receiver fetcher.\n\n        This receiver will receive a message whenever the current running\n        status of a dispatch changes.\n\n        Usually, one message per scheduled run is to be expected.\n        However, things get complicated when a dispatch was modified:\n\n        If it was currently running and the modification now says\n        it should not be running or running with different parameters,\n        then a message will be sent.\n\n        In other words: Any change that is expected to make an actor start, stop\n        or reconfigure itself with new parameters causes a message to be\n        sent.\n\n        A non-exhaustive list of possible changes that will cause a message to be sent:\n         - The normal scheduled start_time has been reached\n         - The duration of the dispatch has been modified\n         - The start_time has been modified to be in the future\n         - The component selection changed\n         - The active status changed\n         - The dry_run status changed\n         - The payload changed\n         - The dispatch was deleted\n\n        Note: Reaching the end time (start_time + duration) will not\n        send a message, except when it was reached by modifying the duration.\n\n\n        Returns:\n            A new receiver for dispatches whose running status changed.\n        \"\"\"\n        return self._running_state_channel\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.client","title":"client  <code>property</code>","text":"<pre><code>client: Client\n</code></pre> <p>Return the client.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.lifecycle_events","title":"lifecycle_events  <code>property</code>","text":"<pre><code>lifecycle_events: ReceiverFetcher[DispatchEvent]\n</code></pre> <p>Return new, updated or deleted dispatches receiver fetcher.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[DispatchEvent]</code> <p>A new receiver for new dispatches.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.running_status_change","title":"running_status_change  <code>property</code>","text":"<pre><code>running_status_change: ReceiverFetcher[Dispatch]\n</code></pre> <p>Return running status change receiver fetcher.</p> <p>This receiver will receive a message whenever the current running status of a dispatch changes.</p> <p>Usually, one message per scheduled run is to be expected. However, things get complicated when a dispatch was modified:</p> <p>If it was currently running and the modification now says it should not be running or running with different parameters, then a message will be sent.</p> <p>In other words: Any change that is expected to make an actor start, stop or reconfigure itself with new parameters causes a message to be sent.</p> A non-exhaustive list of possible changes that will cause a message to be sent <ul> <li>The normal scheduled start_time has been reached</li> <li>The duration of the dispatch has been modified</li> <li>The start_time has been modified to be in the future</li> <li>The component selection changed</li> <li>The active status changed</li> <li>The dry_run status changed</li> <li>The payload changed</li> <li>The dispatch was deleted</li> </ul> <p>Note: Reaching the end time (start_time + duration) will not send a message, except when it was reached by modifying the duration.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Dispatch]</code> <p>A new receiver for dispatches whose running status changed.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    microgrid_id: int,\n    grpc_channel: Channel,\n    svc_addr: str,\n    key: str\n)\n</code></pre> <p>Initialize the dispatcher.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid id.</p> <p> TYPE: <code>int</code> </p> <code>grpc_channel</code> <p>The gRPC channel.</p> <p> TYPE: <code>Channel</code> </p> <code>svc_addr</code> <p>The service address.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key to access the service.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>def __init__(\n    self,\n    *,\n    microgrid_id: int,\n    grpc_channel: grpc.aio.Channel,\n    svc_addr: str,\n    key: str,\n):\n    \"\"\"Initialize the dispatcher.\n\n    Args:\n        microgrid_id: The microgrid id.\n        grpc_channel: The gRPC channel.\n        svc_addr: The service address.\n        key: The key to access the service.\n    \"\"\"\n    self._running_state_channel = Broadcast[Dispatch](name=\"running_state_change\")\n    self._lifecycle_events_channel = Broadcast[DispatchEvent](\n        name=\"lifecycle_events\"\n    )\n    self._client = Client(grpc_channel=grpc_channel, svc_addr=svc_addr, key=key)\n    self._actor = DispatchingActor(\n        microgrid_id,\n        self._client,\n        self._lifecycle_events_channel.new_sender(),\n        self._running_state_channel.new_sender(),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the actor.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the actor.\"\"\"\n    self._actor.start()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ReceiverFetcher","title":"frequenz.dispatch.ReceiverFetcher","text":"<p>               Bases: <code>Protocol[ReceivedT_co]</code></p> <p>An interface that just exposes a <code>new_receiver</code> method.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>class ReceiverFetcher(Protocol[ReceivedT_co]):\n    \"\"\"An interface that just exposes a `new_receiver` method.\"\"\"\n\n    @abc.abstractmethod\n    def new_receiver(\n        self, *, name: str | None = None, limit: int = 50\n    ) -&gt; Receiver[ReceivedT_co]:\n        \"\"\"Get a receiver from the channel.\n\n        Args:\n            name: A name to identify the receiver in the logs.\n            limit: The maximum size of the receiver.\n\n        Returns:\n            A receiver instance.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ReceiverFetcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ReceiverFetcher.new_receiver","title":"new_receiver  <code>abstractmethod</code>","text":"<pre><code>new_receiver(\n    *, name: str | None = None, limit: int = 50\n) -&gt; Receiver[ReceivedT_co]\n</code></pre> <p>Get a receiver from the channel.</p> PARAMETER DESCRIPTION <code>name</code> <p>A name to identify the receiver in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>The maximum size of the receiver.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[ReceivedT_co]</code> <p>A receiver instance.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>@abc.abstractmethod\ndef new_receiver(\n    self, *, name: str | None = None, limit: int = 50\n) -&gt; Receiver[ReceivedT_co]:\n    \"\"\"Get a receiver from the channel.\n\n    Args:\n        name: A name to identify the receiver in the logs.\n        limit: The maximum size of the receiver.\n\n    Returns:\n        A receiver instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState","title":"frequenz.dispatch.RunningState","text":"<p>               Bases: <code>Enum</code></p> <p>The running state of a dispatch.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>class RunningState(Enum):\n    \"\"\"The running state of a dispatch.\"\"\"\n\n    RUNNING = \"RUNNING\"\n    \"\"\"The dispatch is running.\"\"\"\n\n    STOPPED = \"STOPPED\"\n    \"\"\"The dispatch is stopped.\"\"\"\n\n    DIFFERENT_TYPE = \"DIFFERENT_TYPE\"\n    \"\"\"The dispatch is for a different type.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState.DIFFERENT_TYPE","title":"DIFFERENT_TYPE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIFFERENT_TYPE = 'DIFFERENT_TYPE'\n</code></pre> <p>The dispatch is for a different type.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'RUNNING'\n</code></pre> <p>The dispatch is running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState.STOPPED","title":"STOPPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPED = 'STOPPED'\n</code></pre> <p>The dispatch is stopped.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated","title":"frequenz.dispatch.Updated  <code>dataclass</code>","text":"<p>A dispatch updated event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Updated:\n    \"\"\"A dispatch updated event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was updated.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was updated.</p>"},{"location":"reference/frequenz/dispatch/actor/","title":"actor","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor","title":"frequenz.dispatch.actor","text":"<p>The dispatch actor.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor","title":"frequenz.dispatch.actor.DispatchingActor","text":"<p>               Bases: <code>Actor</code></p> <p>Dispatch actor.</p> <p>This actor is responsible for handling dispatches for a microgrid.</p> <p>This means staying in sync with the API and scheduling dispatches as necessary.</p> Source code in <code>frequenz/dispatch/actor.py</code> <pre><code>class DispatchingActor(Actor):\n    \"\"\"Dispatch actor.\n\n    This actor is responsible for handling dispatches for a microgrid.\n\n    This means staying in sync with the API and scheduling\n    dispatches as necessary.\n    \"\"\"\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        microgrid_id: int,\n        client: Client,\n        lifecycle_updates_sender: Sender[DispatchEvent],\n        running_state_change_sender: Sender[Dispatch],\n        poll_interval: timedelta = _DEFAULT_POLL_INTERVAL,\n    ) -&gt; None:\n        \"\"\"Initialize the actor.\n\n        Args:\n            microgrid_id: The microgrid ID to handle dispatches for.\n            client: The client to use for fetching dispatches.\n            lifecycle_updates_sender: A sender for dispatch lifecycle events.\n            running_state_change_sender: A sender for dispatch running state changes.\n            poll_interval: The interval to poll the API for dispatche changes.\n        \"\"\"\n        super().__init__(name=\"dispatch\")\n\n        self._client = client\n        self._dispatches: dict[int, Dispatch] = {}\n        self._scheduled: dict[int, asyncio.Task[None]] = {}\n        self._microgrid_id = microgrid_id\n        self._lifecycle_updates_sender = lifecycle_updates_sender\n        self._running_state_change_sender = running_state_change_sender\n        self._poll_timer = Timer(poll_interval, SkipMissedAndDrift())\n\n    async def _run(self) -&gt; None:\n        \"\"\"Run the actor.\"\"\"\n        self._poll_timer.reset()\n        try:\n            async for _ in self._poll_timer:\n                await self._fetch()\n        except asyncio.CancelledError:\n            for task in self._scheduled.values():\n                task.cancel()\n            raise\n\n    async def _fetch(self) -&gt; None:\n        \"\"\"Fetch all relevant dispatches.\"\"\"\n        old_dispatches = self._dispatches\n        self._dispatches = {}\n\n        try:\n            _logger.info(\"Fetching dispatches for microgrid %s\", self._microgrid_id)\n            async for client_dispatch in self._client.list(\n                microgrid_id=self._microgrid_id\n            ):\n                dispatch = Dispatch(client_dispatch)\n\n                self._dispatches[dispatch.id] = Dispatch(client_dispatch)\n                old_dispatch = old_dispatches.pop(dispatch.id, None)\n                if not old_dispatch:\n                    self._update_dispatch_schedule(dispatch, None)\n                    _logger.info(\"New dispatch: %s\", dispatch)\n                    await self._lifecycle_updates_sender.send(\n                        Created(dispatch=dispatch)\n                    )\n                elif dispatch.update_time != old_dispatch.update_time:\n                    self._update_dispatch_schedule(dispatch, old_dispatch)\n                    _logger.info(\"Updated dispatch: %s\", dispatch)\n                    await self._lifecycle_updates_sender.send(\n                        Updated(dispatch=dispatch)\n                    )\n\n                    if self._running_state_change(dispatch, old_dispatch):\n                        await self._send_running_state_change(dispatch)\n\n        except grpc.aio.AioRpcError as error:\n            _logger.error(\"Error fetching dispatches: %s\", error)\n            self._dispatches = old_dispatches\n            return\n\n        for dispatch in old_dispatches.values():\n            _logger.info(\"Deleted dispatch: %s\", dispatch)\n            dispatch._set_deleted()  # pylint: disable=protected-access\n            await self._lifecycle_updates_sender.send(Deleted(dispatch=dispatch))\n            if task := self._scheduled.pop(dispatch.id, None):\n                task.cancel()\n\n            if self._running_state_change(None, dispatch):\n                await self._send_running_state_change(dispatch)\n\n    def _update_dispatch_schedule(\n        self, dispatch: Dispatch, old_dispatch: Dispatch | None\n    ) -&gt; None:\n        \"\"\"Update the schedule for a dispatch.\n\n        Schedules, reschedules or cancels the dispatch based on the start_time\n        and active status.\n\n        For example:\n            * when the start_time changes, the dispatch is rescheduled\n            * when the dispatch is deactivated, the dispatch is cancelled\n\n        Args:\n            dispatch: The dispatch to update the schedule for.\n            old_dispatch: The old dispatch, if available.\n        \"\"\"\n        if (\n            old_dispatch\n            and old_dispatch.active\n            and old_dispatch.start_time != dispatch.start_time\n        ):\n            if task := self._scheduled.pop(dispatch.id, None):\n                task.cancel()\n\n        if dispatch.active and dispatch.id not in self._scheduled:\n            self._scheduled[dispatch.id] = asyncio.create_task(\n                self._schedule_task(dispatch)\n            )\n\n    async def _schedule_task(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Wait for a dispatch to become ready.\n\n        Waits for the dispatches next run and then notifies that it is ready.\n\n        Args:\n            dispatch: The dispatch to schedule.\n        \"\"\"\n\n        def next_run_info() -&gt; tuple[datetime, datetime] | None:\n            now = datetime.now(tz=timezone.utc)\n            next_run = dispatch.next_run_after(now)\n\n            if next_run is None:\n                return None\n\n            return now, next_run\n\n        while pair := next_run_info():\n            now, next_time = pair\n\n            if next_time - now &gt; _MAX_AHEAD_SCHEDULE:\n                await asyncio.sleep(_MAX_AHEAD_SCHEDULE.total_seconds())\n                continue\n\n            _logger.info(\"Dispatch %s scheduled for %s\", dispatch.id, next_time)\n            await asyncio.sleep((next_time - now).total_seconds())\n\n            _logger.info(\"Dispatch ready: %s\", dispatch)\n            await self._running_state_change_sender.send(dispatch)\n\n        _logger.info(\"Dispatch finished: %s\", dispatch)\n        self._scheduled.pop(dispatch.id)\n\n    def _running_state_change(\n        self, updated_dispatch: Dispatch | None, previous_dispatch: Dispatch | None\n    ) -&gt; bool:\n        \"\"\"Check if the running state of a dispatch has changed.\n\n        Checks if any of the running state changes to the dispatch\n        require a new message to be sent to the actor so that it can potentially\n        change its runtime configuration or start/stop itself.\n\n        Also checks if a dispatch update was not sent due to connection issues\n        in which case we need to send the message now.\n\n        Args:\n            updated_dispatch: The new dispatch, if available.\n            previous_dispatch: The old dispatch, if available.\n\n        Returns:\n            True if the running state has changed, False otherwise.\n        \"\"\"\n        # New dispatch\n        if previous_dispatch is None:\n            assert updated_dispatch is not None\n\n            # Client was not informed about the dispatch, do it now\n            # pylint: disable=protected-access\n            if not updated_dispatch._running_status_notified:\n                return True\n\n        # Deleted dispatch\n        if updated_dispatch is None:\n            assert previous_dispatch is not None\n            return (\n                previous_dispatch.running(previous_dispatch.type)\n                == RunningState.RUNNING\n            )\n\n        # If any of the runtime attributes changed, we need to send a message\n        runtime_state_attributes = [\n            \"running\",\n            \"type\",\n            \"selector\",\n            \"duration\",\n            \"dry_run\",\n            \"payload\",\n        ]\n\n        for attribute in runtime_state_attributes:\n            if getattr(updated_dispatch, attribute) != getattr(\n                previous_dispatch, attribute\n            ):\n                return True\n\n        return False\n\n    async def _send_running_state_change(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Send a running state change message.\n\n        Args:\n            dispatch: The dispatch that changed.\n        \"\"\"\n        await self._running_state_change_sender.send(dispatch)\n        # Update the last sent notification time\n        # so we know if this change was already sent\n        dispatch._set_running_status_notified()  # pylint: disable=protected-access\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    microgrid_id: int,\n    client: Client,\n    lifecycle_updates_sender: Sender[DispatchEvent],\n    running_state_change_sender: Sender[Dispatch],\n    poll_interval: timedelta = _DEFAULT_POLL_INTERVAL,\n) -&gt; None\n</code></pre> <p>Initialize the actor.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid ID to handle dispatches for.</p> <p> TYPE: <code>int</code> </p> <code>client</code> <p>The client to use for fetching dispatches.</p> <p> TYPE: <code>Client</code> </p> <code>lifecycle_updates_sender</code> <p>A sender for dispatch lifecycle events.</p> <p> TYPE: <code>Sender[DispatchEvent]</code> </p> <code>running_state_change_sender</code> <p>A sender for dispatch running state changes.</p> <p> TYPE: <code>Sender[Dispatch]</code> </p> <code>poll_interval</code> <p>The interval to poll the API for dispatche changes.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>_DEFAULT_POLL_INTERVAL</code> </p> Source code in <code>frequenz/dispatch/actor.py</code> <pre><code>def __init__(\n    self,\n    microgrid_id: int,\n    client: Client,\n    lifecycle_updates_sender: Sender[DispatchEvent],\n    running_state_change_sender: Sender[Dispatch],\n    poll_interval: timedelta = _DEFAULT_POLL_INTERVAL,\n) -&gt; None:\n    \"\"\"Initialize the actor.\n\n    Args:\n        microgrid_id: The microgrid ID to handle dispatches for.\n        client: The client to use for fetching dispatches.\n        lifecycle_updates_sender: A sender for dispatch lifecycle events.\n        running_state_change_sender: A sender for dispatch running state changes.\n        poll_interval: The interval to poll the API for dispatche changes.\n    \"\"\"\n    super().__init__(name=\"dispatch\")\n\n    self._client = client\n    self._dispatches: dict[int, Dispatch] = {}\n    self._scheduled: dict[int, asyncio.Task[None]] = {}\n    self._microgrid_id = microgrid_id\n    self._lifecycle_updates_sender = lifecycle_updates_sender\n    self._running_state_change_sender = running_state_change_sender\n    self._poll_timer = Timer(poll_interval, SkipMissedAndDrift())\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"}]}