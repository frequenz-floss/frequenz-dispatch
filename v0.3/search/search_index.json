{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Highlevel Interface","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A highlevel interface for the dispatch API.</p> <p>See the documentation for more information.</p>"},{"location":"#usage","title":"Usage","text":"<p>The <code>Dispatcher</code> class, the main entry point for the API, provides two channels:</p> <ul> <li>Lifecycle events: A channel that sends a message whenever a Dispatch is created, updated or deleted.</li> <li>Running status change: Sends a dispatch message whenever a dispatch is ready to be executed according to the schedule or the running status of the dispatch changed in a way that could potentially require the actor to start, stop or reconfigure itself.</li> </ul>"},{"location":"#example-using-the-running-status-change-channel","title":"Example using the running status change channel","text":"<pre><code>import os\nfrom frequenz.dispatch import Dispatcher, RunningState\nfrom unittest.mock import MagicMock\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()\n\n    actor = MagicMock() # replace with your actor\n\n    changed_running_status_rx = dispatcher.running_status_change.new_receiver()\n\n    async for dispatch in changed_running_status_rx:\n        match dispatch.running(\"DEMO_TYPE\"):\n            case RunningState.RUNNING:\n                print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                if actor.is_running:\n                    actor.reconfigure(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )  # this will reconfigure the actor\n                else:\n                    # this will start a new actor with the given components\n                    # and run it for the duration of the dispatch\n                    actor.start(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )\n            case RunningState.STOPPED:\n                actor.stop()  # this will stop the actor\n            case RunningState.DIFFERENT_TYPE:\n                pass  # dispatch not for this type\n</code></pre>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Dispatch Highlevel Interface","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>dispatch<ul> <li>actor</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/dispatch/","title":"Index","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch","title":"frequenz.dispatch","text":"<p>A highlevel interface for the dispatch API.</p> <p>A small overview of the most important classes in this module:</p> <ul> <li>Dispatcher: The entry point for the API.</li> <li>Dispatch: A dispatch type with lots of useful extra functionality.</li> <li>DispatchManagingActor: An actor to     manage other actors based on incoming dispatches.</li> <li>Created,   Updated,   Deleted: Dispatch event types.</li> </ul>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchEvent","title":"frequenz.dispatch.DispatchEvent  <code>module-attribute</code>","text":"<pre><code>DispatchEvent = Created | Updated | Deleted\n</code></pre> <p>Type that is sent over the channel for dispatch updates.</p> <p>This type is used to send dispatches that were created, updated or deleted over the channel.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch-classes","title":"Classes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created","title":"frequenz.dispatch.Created  <code>dataclass</code>","text":"<p>A dispatch created event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Created:\n    \"\"\"A dispatch created event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was created.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Created.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was created.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted","title":"frequenz.dispatch.Deleted  <code>dataclass</code>","text":"<p>A dispatch deleted event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Deleted:\n    \"\"\"A dispatch deleted event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was deleted.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Deleted.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was deleted.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch","title":"frequenz.dispatch.Dispatch  <code>dataclass</code>","text":"<p>               Bases: <code>Dispatch</code></p> <p>Dispatch type with extra functionality.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>@dataclass(frozen=True)\nclass Dispatch(BaseDispatch):\n    \"\"\"Dispatch type with extra functionality.\"\"\"\n\n    deleted: bool = False\n    \"\"\"Whether the dispatch is deleted.\"\"\"\n\n    running_state_change_synced: datetime | None = None\n    \"\"\"The last time a message was sent about the running state change.\"\"\"\n\n    def __init__(\n        self,\n        client_dispatch: BaseDispatch,\n        deleted: bool = False,\n        running_state_change_synced: datetime | None = None,\n    ):\n        \"\"\"Initialize the dispatch.\n\n        Args:\n            client_dispatch: The client dispatch.\n            deleted: Whether the dispatch is deleted.\n            running_state_change_synced: Timestamp of the last running state change message.\n        \"\"\"\n        super().__init__(**client_dispatch.__dict__)\n        # Work around frozen to set deleted\n        object.__setattr__(self, \"deleted\", deleted)\n        object.__setattr__(\n            self,\n            \"running_state_change_synced\",\n            running_state_change_synced,\n        )\n\n    def _set_deleted(self) -&gt; None:\n        \"\"\"Mark the dispatch as deleted.\"\"\"\n        object.__setattr__(self, \"deleted\", True)\n\n    @property\n    def _running_status_notified(self) -&gt; bool:\n        \"\"\"Check that the latest running state change notification was sent.\n\n        Returns:\n            True if the latest running state change notification was sent, False otherwise.\n        \"\"\"\n        return self.running_state_change_synced == self.update_time\n\n    def _set_running_status_notified(self) -&gt; None:\n        \"\"\"Mark the latest running state change notification as sent.\"\"\"\n        object.__setattr__(self, \"running_state_change_synced\", self.update_time)\n\n    def running(self, type_: str) -&gt; RunningState:\n        \"\"\"Check if the dispatch is currently supposed to be running.\n\n        Args:\n            type_: The type of the dispatch that should be running.\n\n        Returns:\n            RUNNING if the dispatch is running,\n            STOPPED if it is stopped,\n            DIFFERENT_TYPE if it is for a different type.\n        \"\"\"\n        if self.type != type_:\n            return RunningState.DIFFERENT_TYPE\n\n        if not self.active or self.deleted:\n            return RunningState.STOPPED\n\n        now = datetime.now(tz=timezone.utc)\n\n        if now &lt; self.start_time:\n            return RunningState.STOPPED\n        # A dispatch without duration is always running once it started\n        if self.duration is None:\n            return RunningState.RUNNING\n\n        if until := self._until(now):\n            return RunningState.RUNNING if now &lt; until else RunningState.STOPPED\n\n        return RunningState.STOPPED\n\n    @property\n    def until(self) -&gt; datetime | None:\n        \"\"\"Time when the dispatch should end.\n\n        Returns the time that a running dispatch should end.\n        If the dispatch is not running, None is returned.\n\n        Returns:\n            The time when the dispatch should end or None if the dispatch is not running.\n        \"\"\"\n        if not self.active or self.deleted:\n            return None\n\n        now = datetime.now(tz=timezone.utc)\n        return self._until(now)\n\n    @property\n    # noqa is needed because of a bug in pydoclint that makes it think a `return` without a return\n    # value needs documenting\n    def missed_runs(self) -&gt; Iterator[datetime]:  # noqa: DOC405\n        \"\"\"Yield all missed runs of a dispatch.\n\n        Yields all missed runs of a dispatch.\n\n        If a running state change notification was not sent in time\n        due to connection issues, this method will yield all missed runs\n        since the last sent notification.\n\n        Returns:\n            A generator that yields all missed runs of a dispatch.\n        \"\"\"\n        if self.update_time == self.running_state_change_synced:\n            return\n\n        from_time = self.update_time\n        now = datetime.now(tz=timezone.utc)\n\n        while (next_run := self.next_run_after(from_time)) and next_run &lt; now:\n            yield next_run\n            from_time = next_run\n\n    @property\n    def next_run(self) -&gt; datetime | None:\n        \"\"\"Calculate the next run of a dispatch.\n\n        Returns:\n            The next run of the dispatch or None if the dispatch is finished.\n        \"\"\"\n        return self.next_run_after(datetime.now(tz=timezone.utc))\n\n    def next_run_after(self, after: datetime) -&gt; datetime | None:\n        \"\"\"Calculate the next run of a dispatch.\n\n        Args:\n            after: The time to calculate the next run from.\n\n        Returns:\n            The next run of the dispatch or None if the dispatch is finished.\n        \"\"\"\n        if (\n            not self.recurrence.frequency\n            or self.recurrence.frequency == Frequency.UNSPECIFIED\n            or self.duration is None  # Infinite duration\n        ):\n            if after &gt; self.start_time:\n                return None\n            return self.start_time\n\n        # Make sure no weekday is UNSPECIFIED\n        if Weekday.UNSPECIFIED in self.recurrence.byweekdays:\n            _logger.warning(\"Dispatch %s has UNSPECIFIED weekday, ignoring...\", self.id)\n            return None\n\n        # No type information for rrule, so we need to cast\n        return cast(datetime | None, self._prepare_rrule().after(after, inc=True))\n\n    def _prepare_rrule(self) -&gt; rrule.rrule:\n        \"\"\"Prepare the rrule object.\n\n        Returns:\n            The rrule object.\n        \"\"\"\n        count, until = (None, None)\n        if end := self.recurrence.end_criteria:\n            count = end.count\n            until = end.until\n\n        rrule_obj = rrule.rrule(\n            freq=_RRULE_FREQ_MAP[self.recurrence.frequency],\n            dtstart=self.start_time,\n            count=count,\n            until=until,\n            byminute=self.recurrence.byminutes or None,\n            byhour=self.recurrence.byhours or None,\n            byweekday=[\n                _RRULE_WEEKDAY_MAP[weekday] for weekday in self.recurrence.byweekdays\n            ]\n            or None,\n            bymonthday=self.recurrence.bymonthdays or None,\n            bymonth=self.recurrence.bymonths or None,\n            interval=self.recurrence.interval,\n        )\n\n        return rrule_obj\n\n    def _until(self, now: datetime) -&gt; datetime | None:\n        \"\"\"Calculate the time when the dispatch should end.\n\n        If no previous run is found, None is returned.\n\n        Args:\n            now: The current time.\n\n        Returns:\n            The time when the dispatch should end or None if the dispatch is not running.\n\n        Raises:\n            ValueError: If the dispatch has no duration.\n        \"\"\"\n        if self.duration is None:\n            raise ValueError(\"_until: Dispatch has no duration\")\n\n        if (\n            not self.recurrence.frequency\n            or self.recurrence.frequency == Frequency.UNSPECIFIED\n        ):\n            return self.start_time + self.duration\n\n        latest_past_start: datetime | None = self._prepare_rrule().before(now, inc=True)\n\n        if not latest_past_start:\n            return None\n\n        return latest_past_start + self.duration\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.active","title":"active  <code>instance-attribute</code>","text":"<pre><code>active: bool\n</code></pre> <p>Indicates whether the dispatch is active and eligible for processing.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.create_time","title":"create_time  <code>instance-attribute</code>","text":"<pre><code>create_time: datetime\n</code></pre> <p>The creation time of the dispatch in UTC. Set when a dispatch is created.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.deleted","title":"deleted  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deleted: bool = False\n</code></pre> <p>Whether the dispatch is deleted.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Indicates if the dispatch is a dry run.</p> <p>Executed for logging and monitoring without affecting actual component states.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: timedelta | None\n</code></pre> <p>The duration of the dispatch, represented as a timedelta.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique identifier for the dispatch.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.missed_runs","title":"missed_runs  <code>property</code>","text":"<pre><code>missed_runs: Iterator[datetime]\n</code></pre> <p>Yield all missed runs of a dispatch.</p> <p>Yields all missed runs of a dispatch.</p> <p>If a running state change notification was not sent in time due to connection issues, this method will yield all missed runs since the last sent notification.</p> RETURNS DESCRIPTION <code>Iterator[datetime]</code> <p>A generator that yields all missed runs of a dispatch.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.next_run","title":"next_run  <code>property</code>","text":"<pre><code>next_run: datetime | None\n</code></pre> <p>Calculate the next run of a dispatch.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The next run of the dispatch or None if the dispatch is finished.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Any]\n</code></pre> <p>The dispatch payload containing arbitrary data.</p> <p>It is structured as needed for the dispatch operation.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.recurrence","title":"recurrence  <code>instance-attribute</code>","text":"<pre><code>recurrence: RecurrenceRule\n</code></pre> <p>The recurrence rule for the dispatch.</p> <p>Defining any repeating patterns or schedules.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.running_state_change_synced","title":"running_state_change_synced  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>running_state_change_synced: datetime | None = None\n</code></pre> <p>The last time a message was sent about the running state change.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector: ComponentSelector\n</code></pre> <p>The component selector specifying which components the dispatch targets.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime\n</code></pre> <p>The start time of the dispatch in UTC.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>User-defined information about the type of dispatch.</p> <p>This is understood and processed by downstream applications.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.until","title":"until  <code>property</code>","text":"<pre><code>until: datetime | None\n</code></pre> <p>Time when the dispatch should end.</p> <p>Returns the time that a running dispatch should end. If the dispatch is not running, None is returned.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The time when the dispatch should end or None if the dispatch is not running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.update_time","title":"update_time  <code>instance-attribute</code>","text":"<pre><code>update_time: datetime\n</code></pre> <p>The last update time of the dispatch in UTC. Set when a dispatch is modified.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.__init__","title":"__init__","text":"<pre><code>__init__(\n    client_dispatch: Dispatch,\n    deleted: bool = False,\n    running_state_change_synced: datetime | None = None,\n)\n</code></pre> <p>Initialize the dispatch.</p> PARAMETER DESCRIPTION <code>client_dispatch</code> <p>The client dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> <code>deleted</code> <p>Whether the dispatch is deleted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>running_state_change_synced</code> <p>Timestamp of the last running state change message.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def __init__(\n    self,\n    client_dispatch: BaseDispatch,\n    deleted: bool = False,\n    running_state_change_synced: datetime | None = None,\n):\n    \"\"\"Initialize the dispatch.\n\n    Args:\n        client_dispatch: The client dispatch.\n        deleted: Whether the dispatch is deleted.\n        running_state_change_synced: Timestamp of the last running state change message.\n    \"\"\"\n    super().__init__(**client_dispatch.__dict__)\n    # Work around frozen to set deleted\n    object.__setattr__(self, \"deleted\", deleted)\n    object.__setattr__(\n        self,\n        \"running_state_change_synced\",\n        running_state_change_synced,\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_object: Dispatch) -&gt; Dispatch\n</code></pre> <p>Convert a protobuf dispatch to a dispatch.</p> PARAMETER DESCRIPTION <code>pb_object</code> <p>The protobuf dispatch to convert.</p> <p> TYPE: <code>Dispatch</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_object: PBDispatch) -&gt; \"Dispatch\":\n    \"\"\"Convert a protobuf dispatch to a dispatch.\n\n    Args:\n        pb_object: The protobuf dispatch to convert.\n\n    Returns:\n        The converted dispatch.\n    \"\"\"\n    return Dispatch(\n        id=pb_object.metadata.dispatch_id,\n        type=pb_object.data.type,\n        create_time=to_datetime(pb_object.metadata.create_time),\n        update_time=to_datetime(pb_object.metadata.modification_time),\n        start_time=to_datetime(pb_object.data.start_time),\n        duration=(\n            timedelta(seconds=pb_object.data.duration)\n            if pb_object.data.duration\n            else None\n        ),\n        selector=component_selector_from_protobuf(pb_object.data.selector),\n        active=pb_object.data.is_active,\n        dry_run=pb_object.data.is_dry_run,\n        payload=MessageToDict(pb_object.data.payload),\n        recurrence=RecurrenceRule.from_protobuf(pb_object.data.recurrence),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.next_run_after","title":"next_run_after","text":"<pre><code>next_run_after(after: datetime) -&gt; datetime | None\n</code></pre> <p>Calculate the next run of a dispatch.</p> PARAMETER DESCRIPTION <code>after</code> <p>The time to calculate the next run from.</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The next run of the dispatch or None if the dispatch is finished.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def next_run_after(self, after: datetime) -&gt; datetime | None:\n    \"\"\"Calculate the next run of a dispatch.\n\n    Args:\n        after: The time to calculate the next run from.\n\n    Returns:\n        The next run of the dispatch or None if the dispatch is finished.\n    \"\"\"\n    if (\n        not self.recurrence.frequency\n        or self.recurrence.frequency == Frequency.UNSPECIFIED\n        or self.duration is None  # Infinite duration\n    ):\n        if after &gt; self.start_time:\n            return None\n        return self.start_time\n\n    # Make sure no weekday is UNSPECIFIED\n    if Weekday.UNSPECIFIED in self.recurrence.byweekdays:\n        _logger.warning(\"Dispatch %s has UNSPECIFIED weekday, ignoring...\", self.id)\n        return None\n\n    # No type information for rrule, so we need to cast\n    return cast(datetime | None, self._prepare_rrule().after(after, inc=True))\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.running","title":"running","text":"<pre><code>running(type_: str) -&gt; RunningState\n</code></pre> <p>Check if the dispatch is currently supposed to be running.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the dispatch that should be running.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>RunningState</code> <p>RUNNING if the dispatch is running,</p> <code>RunningState</code> <p>STOPPED if it is stopped,</p> <code>RunningState</code> <p>DIFFERENT_TYPE if it is for a different type.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>def running(self, type_: str) -&gt; RunningState:\n    \"\"\"Check if the dispatch is currently supposed to be running.\n\n    Args:\n        type_: The type of the dispatch that should be running.\n\n    Returns:\n        RUNNING if the dispatch is running,\n        STOPPED if it is stopped,\n        DIFFERENT_TYPE if it is for a different type.\n    \"\"\"\n    if self.type != type_:\n        return RunningState.DIFFERENT_TYPE\n\n    if not self.active or self.deleted:\n        return RunningState.STOPPED\n\n    now = datetime.now(tz=timezone.utc)\n\n    if now &lt; self.start_time:\n        return RunningState.STOPPED\n    # A dispatch without duration is always running once it started\n    if self.duration is None:\n        return RunningState.RUNNING\n\n    if until := self._until(now):\n        return RunningState.RUNNING if now &lt; until else RunningState.STOPPED\n\n    return RunningState.STOPPED\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatch.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; Dispatch\n</code></pre> <p>Convert a dispatch to a protobuf dispatch.</p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted protobuf dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBDispatch:\n    \"\"\"Convert a dispatch to a protobuf dispatch.\n\n    Returns:\n        The converted protobuf dispatch.\n    \"\"\"\n    payload = Struct()\n    payload.update(self.payload)\n\n    return PBDispatch(\n        metadata=DispatchMetadata(\n            dispatch_id=self.id,\n            create_time=to_timestamp(self.create_time),\n            modification_time=to_timestamp(self.update_time),\n        ),\n        data=DispatchData(\n            type=self.type,\n            start_time=to_timestamp(self.start_time),\n            duration=(\n                round(self.duration.total_seconds()) if self.duration else None\n            ),\n            selector=component_selector_to_protobuf(self.selector),\n            is_active=self.active,\n            is_dry_run=self.dry_run,\n            payload=payload,\n            recurrence=self.recurrence.to_protobuf() if self.recurrence else None,\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor","title":"frequenz.dispatch.DispatchManagingActor","text":"<p>               Bases: <code>Actor</code></p> <p>Helper class to manage actors based on dispatches.</p> <p>Example usage:</p> <pre><code>import os\nimport asyncio\nfrom frequenz.dispatch import Dispatcher, DispatchManagingActor, DispatchUpdate\nfrom frequenz.client.dispatch.types import ComponentSelector\nfrom frequenz.client.common.microgrid.components import ComponentCategory\n\nfrom frequenz.channels import Receiver, Broadcast\n\nclass MyActor(Actor):\n    def __init__(self, updates_channel: Receiver[DispatchUpdate]):\n        super().__init__()\n        self._updates_channel = updates_channel\n        self._dry_run: bool\n        self._options : dict[str, Any]\n\n    async def _run(self) -&gt; None:\n        while True:\n            update = await self._updates_channel.receive()\n            print(\"Received update:\", update)\n\n            self.set_components(update.components)\n            self._dry_run = update.dry_run\n            self._options = update.options\n\n    def set_components(self, components: ComponentSelector) -&gt; None:\n        match components:\n            case [int(), *_] as component_ids:\n                print(\"Dispatch: Setting components to %s\", components)\n            case [ComponentCategory.BATTERY, *_]:\n                print(\"Dispatch: Using all battery components\")\n            case unsupported:\n                print(\n                    \"Dispatch: Requested an unsupported selector %r, \"\n                    \"but only component IDs or category BATTERY are supported.\",\n                    unsupported,\n                )\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n\n    # Create update channel to receive dispatch update events pre-start and mid-run\n    dispatch_updates_channel = Broadcast[DispatchUpdate](name=\"dispatch_updates_channel\")\n\n    # Start actor and give it an dispatch updates channel receiver\n    my_actor = MyActor(dispatch_updates_channel.new_receiver())\n\n    status_receiver = dispatcher.running_status_change.new_receiver()\n\n    managing_actor = DispatchManagingActor(\n        actor=my_actor,\n        dispatch_type=\"EXAMPLE\",\n        running_status_receiver=status_receiver,\n        updates_sender=dispatch_updates_channel.new_sender(),\n    )\n\n    await asyncio.gather(dispatcher.start(), managing_actor.start())\n</code></pre> Source code in <code>frequenz/dispatch/_managing_actor.py</code> <pre><code>class DispatchManagingActor(Actor):\n    \"\"\"Helper class to manage actors based on dispatches.\n\n    Example usage:\n\n    ```python\n    import os\n    import asyncio\n    from frequenz.dispatch import Dispatcher, DispatchManagingActor, DispatchUpdate\n    from frequenz.client.dispatch.types import ComponentSelector\n    from frequenz.client.common.microgrid.components import ComponentCategory\n\n    from frequenz.channels import Receiver, Broadcast\n\n    class MyActor(Actor):\n        def __init__(self, updates_channel: Receiver[DispatchUpdate]):\n            super().__init__()\n            self._updates_channel = updates_channel\n            self._dry_run: bool\n            self._options : dict[str, Any]\n\n        async def _run(self) -&gt; None:\n            while True:\n                update = await self._updates_channel.receive()\n                print(\"Received update:\", update)\n\n                self.set_components(update.components)\n                self._dry_run = update.dry_run\n                self._options = update.options\n\n        def set_components(self, components: ComponentSelector) -&gt; None:\n            match components:\n                case [int(), *_] as component_ids:\n                    print(\"Dispatch: Setting components to %s\", components)\n                case [ComponentCategory.BATTERY, *_]:\n                    print(\"Dispatch: Using all battery components\")\n                case unsupported:\n                    print(\n                        \"Dispatch: Requested an unsupported selector %r, \"\n                        \"but only component IDs or category BATTERY are supported.\",\n                        unsupported,\n                    )\n\n    async def run():\n        url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n        key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n        microgrid_id = 1\n\n        dispatcher = Dispatcher(\n            microgrid_id=microgrid_id,\n            server_url=url,\n            key=key\n        )\n\n        # Create update channel to receive dispatch update events pre-start and mid-run\n        dispatch_updates_channel = Broadcast[DispatchUpdate](name=\"dispatch_updates_channel\")\n\n        # Start actor and give it an dispatch updates channel receiver\n        my_actor = MyActor(dispatch_updates_channel.new_receiver())\n\n        status_receiver = dispatcher.running_status_change.new_receiver()\n\n        managing_actor = DispatchManagingActor(\n            actor=my_actor,\n            dispatch_type=\"EXAMPLE\",\n            running_status_receiver=status_receiver,\n            updates_sender=dispatch_updates_channel.new_sender(),\n        )\n\n        await asyncio.gather(dispatcher.start(), managing_actor.start())\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        actor: Actor | Set[Actor],\n        dispatch_type: str,\n        running_status_receiver: Receiver[Dispatch],\n        updates_sender: Sender[DispatchUpdate] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the dispatch handler.\n\n        Args:\n            actor: A set of actors or a single actor to manage.\n            dispatch_type: The type of dispatches to handle.\n            running_status_receiver: The receiver for dispatch running status changes.\n            updates_sender: The sender for dispatch events\n        \"\"\"\n        super().__init__()\n        self._dispatch_rx = running_status_receiver\n        self._actors = frozenset([actor] if isinstance(actor, Actor) else actor)\n        self._dispatch_type = dispatch_type\n        self._updates_sender = updates_sender\n\n    def _start_actors(self) -&gt; None:\n        \"\"\"Start all actors.\"\"\"\n        for actor in self._actors:\n            if actor.is_running:\n                _logger.warning(\"Actor %s is already running\", actor.name)\n            else:\n                actor.start()\n\n    async def _stop_actors(self, msg: str) -&gt; None:\n        \"\"\"Stop all actors.\n\n        Args:\n            msg: The message to be passed to the actors being stopped.\n        \"\"\"\n        for actor in self._actors:\n            if actor.is_running:\n                await actor.stop(msg)\n            else:\n                _logger.warning(\"Actor %s is not running\", actor.name)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Wait for dispatches and handle them.\"\"\"\n        async for dispatch in self._dispatch_rx:\n            await self._handle_dispatch(dispatch=dispatch)\n\n    async def _handle_dispatch(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Handle a dispatch.\n\n        Args:\n            dispatch: The dispatch to handle.\n        \"\"\"\n        running = dispatch.running(self._dispatch_type)\n        match running:\n            case RunningState.STOPPED:\n                _logger.info(\"Stopped by dispatch %s\", dispatch.id)\n                await self._stop_actors(\"Dispatch stopped\")\n            case RunningState.RUNNING:\n                if self._updates_sender is not None:\n                    _logger.info(\"Updated by dispatch %s\", dispatch.id)\n                    await self._updates_sender.send(\n                        DispatchUpdate(\n                            components=dispatch.selector,\n                            dry_run=dispatch.dry_run,\n                            options=dispatch.payload,\n                        )\n                    )\n\n                _logger.info(\"Started by dispatch %s\", dispatch.id)\n                self._start_actors()\n            case RunningState.DIFFERENT_TYPE:\n                _logger.debug(\n                    \"Unknown dispatch! Ignoring dispatch of type %s\", dispatch.type\n                )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>None</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    actor: Actor | Set[Actor],\n    dispatch_type: str,\n    running_status_receiver: Receiver[Dispatch],\n    updates_sender: Sender[DispatchUpdate] | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the dispatch handler.</p> PARAMETER DESCRIPTION <code>actor</code> <p>A set of actors or a single actor to manage.</p> <p> TYPE: <code>Actor | Set[Actor]</code> </p> <code>dispatch_type</code> <p>The type of dispatches to handle.</p> <p> TYPE: <code>str</code> </p> <code>running_status_receiver</code> <p>The receiver for dispatch running status changes.</p> <p> TYPE: <code>Receiver[Dispatch]</code> </p> <code>updates_sender</code> <p>The sender for dispatch events</p> <p> TYPE: <code>Sender[DispatchUpdate] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/dispatch/_managing_actor.py</code> <pre><code>def __init__(\n    self,\n    actor: Actor | Set[Actor],\n    dispatch_type: str,\n    running_status_receiver: Receiver[Dispatch],\n    updates_sender: Sender[DispatchUpdate] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the dispatch handler.\n\n    Args:\n        actor: A set of actors or a single actor to manage.\n        dispatch_type: The type of dispatches to handle.\n        running_status_receiver: The receiver for dispatch running status changes.\n        updates_sender: The sender for dispatch events\n    \"\"\"\n    super().__init__()\n    self._dispatch_rx = running_status_receiver\n    self._actors = frozenset([actor] if isinstance(actor, Actor) else actor)\n    self._dispatch_type = dispatch_type\n    self._updates_sender = updates_sender\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchManagingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchUpdate","title":"frequenz.dispatch.DispatchUpdate  <code>dataclass</code>","text":"<p>Event emitted when the dispatch changes.</p> Source code in <code>frequenz/dispatch/_managing_actor.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DispatchUpdate:\n    \"\"\"Event emitted when the dispatch changes.\"\"\"\n\n    components: ComponentSelector\n    \"\"\"Components to be used.\"\"\"\n\n    dry_run: bool\n    \"\"\"Whether this is a dry run.\"\"\"\n\n    options: dict[str, Any]\n    \"\"\"Additional options.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchUpdate-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchUpdate.components","title":"components  <code>instance-attribute</code>","text":"<pre><code>components: ComponentSelector\n</code></pre> <p>Components to be used.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchUpdate.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Whether this is a dry run.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.DispatchUpdate.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>Additional options.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher","title":"frequenz.dispatch.Dispatcher","text":"<p>A highlevel interface for the dispatch API.</p> <p>This class provides a highlevel interface to the dispatch API. It provides two channels:</p> Lifecycle events <p>A channel that sends a dispatch event message whenever a dispatch is created, updated or deleted.</p> Running status change <p>Sends a dispatch message whenever a dispatch is ready to be executed according to the schedule or the running status of the dispatch changed in a way that could potentially require the consumer to start, stop or reconfigure itself.</p> Processing running state change dispatches <pre><code>import os\nfrom frequenz.dispatch import Dispatcher, RunningState\nfrom unittest.mock import MagicMock\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()\n\n    actor = MagicMock() # replace with your actor\n\n    changed_running_status = dispatcher.running_status_change.new_receiver()\n\n    async for dispatch in changed_running_status:\n        match dispatch.running(\"DEMO_TYPE\"):\n            case RunningState.RUNNING:\n                print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                if actor.is_running:\n                    actor.reconfigure(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )  # this will reconfigure the actor\n                else:\n                    # this will start a new actor with the given components\n                    # and run it for the duration of the dispatch\n                    actor.start(\n                        components=dispatch.selector,\n                        run_parameters=dispatch.payload, # custom actor parameters\n                        dry_run=dispatch.dry_run,\n                        until=dispatch.until,\n                    )\n            case RunningState.STOPPED:\n                actor.stop()  # this will stop the actor\n            case RunningState.DIFFERENT_TYPE:\n                pass  # dispatch not for this type\n</code></pre> Getting notification about dispatch lifecycle events <pre><code>import os\nfrom typing import assert_never\n\nfrom frequenz.dispatch import Created, Deleted, Dispatcher, Updated\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()  # this will start the actor\n\n    events_receiver = dispatcher.lifecycle_events.new_receiver()\n\n    async for event in events_receiver:\n        match event:\n            case Created(dispatch):\n                print(f\"A dispatch was created: {dispatch}\")\n            case Deleted(dispatch):\n                print(f\"A dispatch was deleted: {dispatch}\")\n            case Updated(dispatch):\n                print(f\"A dispatch was updated: {dispatch}\")\n            case _ as unhandled:\n                assert_never(unhandled)\n</code></pre> Creating a new dispatch and then modifying it. <p>Note that this uses the lower-level <code>Client</code> class to create and update the dispatch.</p> <pre><code>import os\nfrom datetime import datetime, timedelta, timezone\n\nfrom frequenz.client.common.microgrid.components import ComponentCategory\n\nfrom frequenz.dispatch import Dispatcher\n\nasync def run():\n    url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n    key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n    microgrid_id = 1\n\n    dispatcher = Dispatcher(\n        microgrid_id=microgrid_id,\n        server_url=url,\n        key=key\n    )\n    await dispatcher.start()  # this will start the actor\n\n    # Create a new dispatch\n    new_dispatch = await dispatcher.client.create(\n        microgrid_id=microgrid_id,\n        type=\"ECHO_FREQUENCY\",  # replace with your own type\n        start_time=datetime.now(tz=timezone.utc) + timedelta(minutes=10),\n        duration=timedelta(minutes=5),\n        selector=ComponentCategory.INVERTER,\n        payload={\"font\": \"Times New Roman\"},  # Arbitrary payload data\n    )\n\n    # Modify the dispatch\n    await dispatcher.client.update(\n        microgrid_id=microgrid_id,\n        dispatch_id=new_dispatch.id,\n        new_fields={\"duration\": timedelta(minutes=10)}\n    )\n\n    # Validate the modification\n    modified_dispatch = await dispatcher.client.get(\n        microgrid_id=microgrid_id, dispatch_id=new_dispatch.id\n    )\n    assert modified_dispatch.duration == timedelta(minutes=10)\n</code></pre> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>class Dispatcher:\n    \"\"\"A highlevel interface for the dispatch API.\n\n    This class provides a highlevel interface to the dispatch API.\n    It provides two channels:\n\n    Lifecycle events:\n        A channel that sends a dispatch event message whenever a dispatch\n        is created, updated or deleted.\n\n    Running status change:\n        Sends a dispatch message whenever a dispatch is ready\n        to be executed according to the schedule or the running status of the\n        dispatch changed in a way that could potentially require the consumer to start,\n        stop or reconfigure itself.\n\n    Example: Processing running state change dispatches\n        ```python\n        import os\n        from frequenz.dispatch import Dispatcher, RunningState\n        from unittest.mock import MagicMock\n\n        async def run():\n            url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                server_url=url,\n                key=key\n            )\n            await dispatcher.start()\n\n            actor = MagicMock() # replace with your actor\n\n            changed_running_status = dispatcher.running_status_change.new_receiver()\n\n            async for dispatch in changed_running_status:\n                match dispatch.running(\"DEMO_TYPE\"):\n                    case RunningState.RUNNING:\n                        print(f\"Executing dispatch {dispatch.id}, due on {dispatch.start_time}\")\n                        if actor.is_running:\n                            actor.reconfigure(\n                                components=dispatch.selector,\n                                run_parameters=dispatch.payload, # custom actor parameters\n                                dry_run=dispatch.dry_run,\n                                until=dispatch.until,\n                            )  # this will reconfigure the actor\n                        else:\n                            # this will start a new actor with the given components\n                            # and run it for the duration of the dispatch\n                            actor.start(\n                                components=dispatch.selector,\n                                run_parameters=dispatch.payload, # custom actor parameters\n                                dry_run=dispatch.dry_run,\n                                until=dispatch.until,\n                            )\n                    case RunningState.STOPPED:\n                        actor.stop()  # this will stop the actor\n                    case RunningState.DIFFERENT_TYPE:\n                        pass  # dispatch not for this type\n        ```\n\n    Example: Getting notification about dispatch lifecycle events\n        ```python\n        import os\n        from typing import assert_never\n\n        from frequenz.dispatch import Created, Deleted, Dispatcher, Updated\n\n        async def run():\n            url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                server_url=url,\n                key=key\n            )\n            await dispatcher.start()  # this will start the actor\n\n            events_receiver = dispatcher.lifecycle_events.new_receiver()\n\n            async for event in events_receiver:\n                match event:\n                    case Created(dispatch):\n                        print(f\"A dispatch was created: {dispatch}\")\n                    case Deleted(dispatch):\n                        print(f\"A dispatch was deleted: {dispatch}\")\n                    case Updated(dispatch):\n                        print(f\"A dispatch was updated: {dispatch}\")\n                    case _ as unhandled:\n                        assert_never(unhandled)\n        ```\n\n    Example: Creating a new dispatch and then modifying it.\n        Note that this uses the lower-level `Client` class to create and update the dispatch.\n\n        ```python\n        import os\n        from datetime import datetime, timedelta, timezone\n\n        from frequenz.client.common.microgrid.components import ComponentCategory\n\n        from frequenz.dispatch import Dispatcher\n\n        async def run():\n            url = os.getenv(\"DISPATCH_API_URL\", \"grpc://fz-0004.frequenz.io:50051\")\n            key  = os.getenv(\"DISPATCH_API_KEY\", \"some-key\")\n\n            microgrid_id = 1\n\n            dispatcher = Dispatcher(\n                microgrid_id=microgrid_id,\n                server_url=url,\n                key=key\n            )\n            await dispatcher.start()  # this will start the actor\n\n            # Create a new dispatch\n            new_dispatch = await dispatcher.client.create(\n                microgrid_id=microgrid_id,\n                type=\"ECHO_FREQUENCY\",  # replace with your own type\n                start_time=datetime.now(tz=timezone.utc) + timedelta(minutes=10),\n                duration=timedelta(minutes=5),\n                selector=ComponentCategory.INVERTER,\n                payload={\"font\": \"Times New Roman\"},  # Arbitrary payload data\n            )\n\n            # Modify the dispatch\n            await dispatcher.client.update(\n                microgrid_id=microgrid_id,\n                dispatch_id=new_dispatch.id,\n                new_fields={\"duration\": timedelta(minutes=10)}\n            )\n\n            # Validate the modification\n            modified_dispatch = await dispatcher.client.get(\n                microgrid_id=microgrid_id, dispatch_id=new_dispatch.id\n            )\n            assert modified_dispatch.duration == timedelta(minutes=10)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        microgrid_id: int,\n        server_url: str,\n        key: str,\n    ):\n        \"\"\"Initialize the dispatcher.\n\n        Args:\n            microgrid_id: The microgrid id.\n            server_url: The URL of the dispatch service.\n            key: The key to access the service.\n        \"\"\"\n        self._running_state_channel = Broadcast[Dispatch](name=\"running_state_change\")\n        self._lifecycle_events_channel = Broadcast[DispatchEvent](\n            name=\"lifecycle_events\"\n        )\n        self._client = Client(server_url=server_url, key=key)\n        self._actor = DispatchingActor(\n            microgrid_id,\n            self._client,\n            self._lifecycle_events_channel.new_sender(),\n            self._running_state_channel.new_sender(),\n        )\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the actor.\"\"\"\n        self._actor.start()\n\n    @property\n    def client(self) -&gt; Client:\n        \"\"\"Return the client.\"\"\"\n        return self._client\n\n    @property\n    def lifecycle_events(self) -&gt; ReceiverFetcher[DispatchEvent]:\n        \"\"\"Return new, updated or deleted dispatches receiver fetcher.\n\n        Returns:\n            A new receiver for new dispatches.\n        \"\"\"\n        return self._lifecycle_events_channel\n\n    @property\n    def running_status_change(self) -&gt; ReceiverFetcher[Dispatch]:\n        \"\"\"Return running status change receiver fetcher.\n\n        This receiver will receive a message whenever the current running\n        status of a dispatch changes.\n\n        Usually, one message per scheduled run is to be expected.\n        However, things get complicated when a dispatch was modified:\n\n        If it was currently running and the modification now says\n        it should not be running or running with different parameters,\n        then a message will be sent.\n\n        In other words: Any change that is expected to make an actor start, stop\n        or reconfigure itself with new parameters causes a message to be\n        sent.\n\n        A non-exhaustive list of possible changes that will cause a message to be sent:\n         - The normal scheduled start_time has been reached\n         - The duration of the dispatch has been modified\n         - The start_time has been modified to be in the future\n         - The component selection changed\n         - The active status changed\n         - The dry_run status changed\n         - The payload changed\n         - The dispatch was deleted\n\n        Note: Reaching the end time (start_time + duration) will not\n        send a message, except when it was reached by modifying the duration.\n\n\n        Returns:\n            A new receiver for dispatches whose running status changed.\n        \"\"\"\n        return self._running_state_channel\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.client","title":"client  <code>property</code>","text":"<pre><code>client: Client\n</code></pre> <p>Return the client.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.lifecycle_events","title":"lifecycle_events  <code>property</code>","text":"<pre><code>lifecycle_events: ReceiverFetcher[DispatchEvent]\n</code></pre> <p>Return new, updated or deleted dispatches receiver fetcher.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[DispatchEvent]</code> <p>A new receiver for new dispatches.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.running_status_change","title":"running_status_change  <code>property</code>","text":"<pre><code>running_status_change: ReceiverFetcher[Dispatch]\n</code></pre> <p>Return running status change receiver fetcher.</p> <p>This receiver will receive a message whenever the current running status of a dispatch changes.</p> <p>Usually, one message per scheduled run is to be expected. However, things get complicated when a dispatch was modified:</p> <p>If it was currently running and the modification now says it should not be running or running with different parameters, then a message will be sent.</p> <p>In other words: Any change that is expected to make an actor start, stop or reconfigure itself with new parameters causes a message to be sent.</p> A non-exhaustive list of possible changes that will cause a message to be sent <ul> <li>The normal scheduled start_time has been reached</li> <li>The duration of the dispatch has been modified</li> <li>The start_time has been modified to be in the future</li> <li>The component selection changed</li> <li>The active status changed</li> <li>The dry_run status changed</li> <li>The payload changed</li> <li>The dispatch was deleted</li> </ul> <p>Note: Reaching the end time (start_time + duration) will not send a message, except when it was reached by modifying the duration.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Dispatch]</code> <p>A new receiver for dispatches whose running status changed.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.__init__","title":"__init__","text":"<pre><code>__init__(*, microgrid_id: int, server_url: str, key: str)\n</code></pre> <p>Initialize the dispatcher.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid id.</p> <p> TYPE: <code>int</code> </p> <code>server_url</code> <p>The URL of the dispatch service.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key to access the service.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>def __init__(\n    self,\n    *,\n    microgrid_id: int,\n    server_url: str,\n    key: str,\n):\n    \"\"\"Initialize the dispatcher.\n\n    Args:\n        microgrid_id: The microgrid id.\n        server_url: The URL of the dispatch service.\n        key: The key to access the service.\n    \"\"\"\n    self._running_state_channel = Broadcast[Dispatch](name=\"running_state_change\")\n    self._lifecycle_events_channel = Broadcast[DispatchEvent](\n        name=\"lifecycle_events\"\n    )\n    self._client = Client(server_url=server_url, key=key)\n    self._actor = DispatchingActor(\n        microgrid_id,\n        self._client,\n        self._lifecycle_events_channel.new_sender(),\n        self._running_state_channel.new_sender(),\n    )\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Dispatcher.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the actor.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the actor.\"\"\"\n    self._actor.start()\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ReceiverFetcher","title":"frequenz.dispatch.ReceiverFetcher","text":"<p>               Bases: <code>Protocol[ReceivedT_co]</code></p> <p>An interface that just exposes a <code>new_receiver</code> method.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>class ReceiverFetcher(Protocol[ReceivedT_co]):\n    \"\"\"An interface that just exposes a `new_receiver` method.\"\"\"\n\n    @abc.abstractmethod\n    def new_receiver(\n        self, *, name: str | None = None, limit: int = 50\n    ) -&gt; Receiver[ReceivedT_co]:\n        \"\"\"Get a receiver from the channel.\n\n        Args:\n            name: A name to identify the receiver in the logs.\n            limit: The maximum size of the receiver.\n\n        Returns:\n            A receiver instance.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ReceiverFetcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.ReceiverFetcher.new_receiver","title":"new_receiver  <code>abstractmethod</code>","text":"<pre><code>new_receiver(\n    *, name: str | None = None, limit: int = 50\n) -&gt; Receiver[ReceivedT_co]\n</code></pre> <p>Get a receiver from the channel.</p> PARAMETER DESCRIPTION <code>name</code> <p>A name to identify the receiver in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>The maximum size of the receiver.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[ReceivedT_co]</code> <p>A receiver instance.</p> Source code in <code>frequenz/dispatch/_dispatcher.py</code> <pre><code>@abc.abstractmethod\ndef new_receiver(\n    self, *, name: str | None = None, limit: int = 50\n) -&gt; Receiver[ReceivedT_co]:\n    \"\"\"Get a receiver from the channel.\n\n    Args:\n        name: A name to identify the receiver in the logs.\n        limit: The maximum size of the receiver.\n\n    Returns:\n        A receiver instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState","title":"frequenz.dispatch.RunningState","text":"<p>               Bases: <code>Enum</code></p> <p>The running state of a dispatch.</p> Source code in <code>frequenz/dispatch/_dispatch.py</code> <pre><code>class RunningState(Enum):\n    \"\"\"The running state of a dispatch.\"\"\"\n\n    RUNNING = \"RUNNING\"\n    \"\"\"The dispatch is running.\"\"\"\n\n    STOPPED = \"STOPPED\"\n    \"\"\"The dispatch is stopped.\"\"\"\n\n    DIFFERENT_TYPE = \"DIFFERENT_TYPE\"\n    \"\"\"The dispatch is for a different type.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState.DIFFERENT_TYPE","title":"DIFFERENT_TYPE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIFFERENT_TYPE = 'DIFFERENT_TYPE'\n</code></pre> <p>The dispatch is for a different type.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'RUNNING'\n</code></pre> <p>The dispatch is running.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.RunningState.STOPPED","title":"STOPPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPED = 'STOPPED'\n</code></pre> <p>The dispatch is stopped.</p>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated","title":"frequenz.dispatch.Updated  <code>dataclass</code>","text":"<p>A dispatch updated event.</p> Source code in <code>frequenz/dispatch/_event.py</code> <pre><code>@dataclass(frozen=True)\nclass Updated:\n    \"\"\"A dispatch updated event.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch that was updated.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/#frequenz.dispatch.Updated.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch that was updated.</p>"},{"location":"reference/frequenz/dispatch/actor/","title":"actor","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor","title":"frequenz.dispatch.actor","text":"<p>The dispatch actor.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor","title":"frequenz.dispatch.actor.DispatchingActor","text":"<p>               Bases: <code>Actor</code></p> <p>Dispatch actor.</p> <p>This actor is responsible for handling dispatches for a microgrid.</p> <p>This means staying in sync with the API and scheduling dispatches as necessary.</p> Source code in <code>frequenz/dispatch/actor.py</code> <pre><code>class DispatchingActor(Actor):\n    \"\"\"Dispatch actor.\n\n    This actor is responsible for handling dispatches for a microgrid.\n\n    This means staying in sync with the API and scheduling\n    dispatches as necessary.\n    \"\"\"\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        microgrid_id: int,\n        client: Client,\n        lifecycle_updates_sender: Sender[DispatchEvent],\n        running_state_change_sender: Sender[Dispatch],\n    ) -&gt; None:\n        \"\"\"Initialize the actor.\n\n        Args:\n            microgrid_id: The microgrid ID to handle dispatches for.\n            client: The client to use for fetching dispatches.\n            lifecycle_updates_sender: A sender for dispatch lifecycle events.\n            running_state_change_sender: A sender for dispatch running state changes.\n        \"\"\"\n        super().__init__(name=\"dispatch\")\n\n        self._client = client\n        self._dispatches: dict[int, Dispatch] = {}\n        self._microgrid_id = microgrid_id\n        self._lifecycle_updates_sender = lifecycle_updates_sender\n        self._running_state_change_sender = running_state_change_sender\n        self._next_event_timer = Timer(\n            timedelta(seconds=100), SkipMissedAndResync(), auto_start=False\n        )\n        \"\"\"The timer to schedule the next event.\n\n        Interval is chosen arbitrarily, as it will be reset on the first event.\n        \"\"\"\n\n        self._scheduled_events: list[tuple[datetime, Dispatch]] = []\n        \"\"\"The scheduled events, sorted by time.\n\n        Each event is a tuple of the scheduled time and the dispatch.\n        heapq is used to keep the list sorted by time, so the next event is\n        always at index 0.\n        \"\"\"\n\n    async def _run(self) -&gt; None:\n        \"\"\"Run the actor.\"\"\"\n        _logger.info(\"Starting dispatch actor for microgrid %s\", self._microgrid_id)\n\n        # Initial fetch\n        await self._fetch()\n\n        stream = self._client.stream(microgrid_id=self._microgrid_id)\n\n        # Streaming updates\n        async for selected in select(self._next_event_timer, stream):\n            if selected_from(selected, self._next_event_timer):\n                if not self._scheduled_events:\n                    continue\n                _logger.debug(\n                    \"Executing scheduled event: %s\", self._scheduled_events[0][1]\n                )\n                await self._execute_scheduled_event(heappop(self._scheduled_events)[1])\n            elif selected_from(selected, stream):\n                _logger.debug(\"Received dispatch event: %s\", selected.message)\n                dispatch = Dispatch(selected.message.dispatch)\n                match selected.message.event:\n                    case Event.CREATED:\n                        self._dispatches[dispatch.id] = dispatch\n                        await self._update_dispatch_schedule_and_notify(dispatch, None)\n                        await self._lifecycle_updates_sender.send(\n                            Created(dispatch=dispatch)\n                        )\n                    case Event.UPDATED:\n                        await self._update_dispatch_schedule_and_notify(\n                            dispatch, self._dispatches[dispatch.id]\n                        )\n                        self._dispatches[dispatch.id] = dispatch\n                        await self._lifecycle_updates_sender.send(\n                            Updated(dispatch=dispatch)\n                        )\n                    case Event.DELETED:\n                        self._dispatches.pop(dispatch.id)\n                        await self._update_dispatch_schedule_and_notify(None, dispatch)\n\n                        dispatch._set_deleted()  # pylint: disable=protected-access\n                        await self._lifecycle_updates_sender.send(\n                            Deleted(dispatch=dispatch)\n                        )\n\n    async def _execute_scheduled_event(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Execute a scheduled event.\n\n        Args:\n            dispatch: The dispatch to execute.\n        \"\"\"\n        await self._send_running_state_change(dispatch)\n\n        # The timer is always a tiny bit delayed, so we need to check if the\n        # actor is supposed to be running now (we're assuming it wasn't already\n        # running, as all checks are done before scheduling)\n        if dispatch.running(dispatch.type) == RunningState.RUNNING:\n            # If it should be running, schedule the stop event\n            self._schedule_stop(dispatch)\n        # If the actor is not running, we need to schedule the next start\n        else:\n            self._schedule_start(dispatch)\n\n        self._update_timer()\n\n    async def _fetch(self) -&gt; None:\n        \"\"\"Fetch all relevant dispatches using list.\n\n        This is used for the initial fetch and for re-fetching all dispatches\n        if the connection was lost.\n        \"\"\"\n        old_dispatches = self._dispatches\n        self._dispatches = {}\n\n        try:\n            _logger.info(\"Fetching dispatches for microgrid %s\", self._microgrid_id)\n            async for page in self._client.list(microgrid_id=self._microgrid_id):\n                for client_dispatch in page:\n                    dispatch = Dispatch(client_dispatch)\n\n                    self._dispatches[dispatch.id] = Dispatch(client_dispatch)\n                    old_dispatch = old_dispatches.pop(dispatch.id, None)\n                    if not old_dispatch:\n                        _logger.info(\"New dispatch: %s\", dispatch)\n                        await self._update_dispatch_schedule_and_notify(dispatch, None)\n                        await self._lifecycle_updates_sender.send(\n                            Created(dispatch=dispatch)\n                        )\n                    elif dispatch.update_time != old_dispatch.update_time:\n                        _logger.info(\"Updated dispatch: %s\", dispatch)\n                        await self._update_dispatch_schedule_and_notify(\n                            dispatch, old_dispatch\n                        )\n                        await self._lifecycle_updates_sender.send(\n                            Updated(dispatch=dispatch)\n                        )\n\n        except grpc.aio.AioRpcError as error:\n            _logger.error(\"Error fetching dispatches: %s\", error)\n            self._dispatches = old_dispatches\n            return\n\n        for dispatch in old_dispatches.values():\n            _logger.info(\"Deleted dispatch: %s\", dispatch)\n            await self._lifecycle_updates_sender.send(Deleted(dispatch=dispatch))\n            await self._update_dispatch_schedule_and_notify(None, dispatch)\n\n            # Set deleted only here as it influences the result of dispatch.running()\n            # which is used in above in _running_state_change\n            dispatch._set_deleted()  # pylint: disable=protected-access\n            await self._lifecycle_updates_sender.send(Deleted(dispatch=dispatch))\n\n    async def _update_dispatch_schedule_and_notify(\n        self, dispatch: Dispatch | None, old_dispatch: Dispatch | None\n    ) -&gt; None:\n        \"\"\"Update the schedule for a dispatch.\n\n        Schedules, reschedules or cancels the dispatch events\n        based on the start_time and active status.\n\n        Sends a running state change notification if necessary.\n\n        For example:\n            * when the start_time changes, the dispatch is rescheduled\n            * when the dispatch is deactivated, the dispatch is cancelled\n\n        Args:\n            dispatch: The dispatch to update the schedule for.\n            old_dispatch: The old dispatch, if available.\n        \"\"\"\n        # If dispatch is None, the dispatch was deleted\n        # and we need to cancel any existing event for it\n        if not dispatch and old_dispatch:\n            self._remove_scheduled(old_dispatch)\n\n            # If the dispatch was running, we need to notify\n            if old_dispatch.running(old_dispatch.type) == RunningState.RUNNING:\n                await self._send_running_state_change(old_dispatch)\n\n        # A new dispatch was created\n        elif dispatch and not old_dispatch:\n            assert not self._remove_scheduled(\n                dispatch\n            ), \"New dispatch already scheduled?!\"\n\n            # If its currently running, send notification right away\n            if dispatch.running(dispatch.type) == RunningState.RUNNING:\n                await self._send_running_state_change(dispatch)\n\n                self._schedule_stop(dispatch)\n            # Otherwise, if it's enabled but not yet running, schedule it\n            else:\n                self._schedule_start(dispatch)\n\n        # Dispatch was updated\n        elif dispatch and old_dispatch:\n            # Remove potentially existing scheduled event\n            self._remove_scheduled(old_dispatch)\n\n            # Check if the change requires an immediate notification\n            if self._update_changed_running_state(dispatch, old_dispatch):\n                await self._send_running_state_change(dispatch)\n\n            if dispatch.running(dispatch.type) == RunningState.RUNNING:\n                self._schedule_stop(dispatch)\n            else:\n                self._schedule_start(dispatch)\n\n        # We modified the schedule, so we need to reset the timer\n        self._update_timer()\n\n    def _update_timer(self) -&gt; None:\n        \"\"\"Update the timer to the next event.\"\"\"\n        if self._scheduled_events:\n            due_at: datetime = self._scheduled_events[0][0]\n            self._next_event_timer.reset(interval=due_at - datetime.now(timezone.utc))\n            _logger.debug(\"Next event scheduled at %s\", self._scheduled_events[0][0])\n\n    def _remove_scheduled(self, dispatch: Dispatch) -&gt; bool:\n        \"\"\"Remove a dispatch from the scheduled events.\n\n        Args:\n            dispatch: The dispatch to remove.\n\n        Returns:\n            True if the dispatch was found and removed, False otherwise.\n        \"\"\"\n        for idx, (_, sched_dispatch) in enumerate(self._scheduled_events):\n            if dispatch.id == sched_dispatch.id:\n                self._scheduled_events.pop(idx)\n                return True\n\n        return False\n\n    def _schedule_start(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Schedule a dispatch to start.\n\n        Args:\n            dispatch: The dispatch to schedule.\n        \"\"\"\n        # If the dispatch is not active, don't schedule it\n        if not dispatch.active:\n            return\n\n        # Schedule the next run\n        try:\n            if next_run := dispatch.next_run:\n                heappush(self._scheduled_events, (next_run, dispatch))\n                _logger.debug(\n                    \"Scheduled dispatch %s to start at %s\", dispatch.id, next_run\n                )\n            else:\n                _logger.debug(\"Dispatch %s has no next run\", dispatch.id)\n        except ValueError as error:\n            _logger.error(\"Error scheduling dispatch %s: %s\", dispatch.id, error)\n\n    def _schedule_stop(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Schedule a dispatch to stop.\n\n        Args:\n            dispatch: The dispatch to schedule.\n        \"\"\"\n        # Setup stop timer if the dispatch has a duration\n        if dispatch.duration and dispatch.duration &gt; timedelta(seconds=0):\n            until = dispatch.until\n            assert until is not None\n            heappush(self._scheduled_events, (until, dispatch))\n            _logger.debug(\"Scheduled dispatch %s to stop at %s\", dispatch, until)\n\n    def _update_changed_running_state(\n        self, updated_dispatch: Dispatch, previous_dispatch: Dispatch\n    ) -&gt; bool:\n        \"\"\"Check if the running state of a dispatch has changed.\n\n        Checks if any of the running state changes to the dispatch\n        require a new message to be sent to the actor so that it can potentially\n        change its runtime configuration or start/stop itself.\n\n        Also checks if a dispatch update was not sent due to connection issues\n        in which case we need to send the message now.\n\n        Args:\n            updated_dispatch: The new dispatch\n            previous_dispatch: The old dispatch\n\n        Returns:\n            True if the running state has changed, False otherwise.\n        \"\"\"\n        # If any of the runtime attributes changed, we need to send a message\n        runtime_state_attributes = [\n            \"running\",\n            \"type\",\n            \"selector\",\n            \"duration\",\n            \"dry_run\",\n            \"payload\",\n        ]\n\n        for attribute in runtime_state_attributes:\n            if getattr(updated_dispatch, attribute) != getattr(\n                previous_dispatch, attribute\n            ):\n                return True\n\n        return False\n\n    async def _send_running_state_change(self, dispatch: Dispatch) -&gt; None:\n        \"\"\"Send a running state change message.\n\n        Args:\n            dispatch: The dispatch that changed.\n        \"\"\"\n        await self._running_state_change_sender.send(dispatch)\n        # Update the last sent notification time\n        # so we know if this change was already sent\n        dispatch._set_running_status_notified()  # pylint: disable=protected-access\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>None</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    microgrid_id: int,\n    client: Client,\n    lifecycle_updates_sender: Sender[DispatchEvent],\n    running_state_change_sender: Sender[Dispatch],\n) -&gt; None\n</code></pre> <p>Initialize the actor.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid ID to handle dispatches for.</p> <p> TYPE: <code>int</code> </p> <code>client</code> <p>The client to use for fetching dispatches.</p> <p> TYPE: <code>Client</code> </p> <code>lifecycle_updates_sender</code> <p>A sender for dispatch lifecycle events.</p> <p> TYPE: <code>Sender[DispatchEvent]</code> </p> <code>running_state_change_sender</code> <p>A sender for dispatch running state changes.</p> <p> TYPE: <code>Sender[Dispatch]</code> </p> Source code in <code>frequenz/dispatch/actor.py</code> <pre><code>def __init__(\n    self,\n    microgrid_id: int,\n    client: Client,\n    lifecycle_updates_sender: Sender[DispatchEvent],\n    running_state_change_sender: Sender[Dispatch],\n) -&gt; None:\n    \"\"\"Initialize the actor.\n\n    Args:\n        microgrid_id: The microgrid ID to handle dispatches for.\n        client: The client to use for fetching dispatches.\n        lifecycle_updates_sender: A sender for dispatch lifecycle events.\n        running_state_change_sender: A sender for dispatch running state changes.\n    \"\"\"\n    super().__init__(name=\"dispatch\")\n\n    self._client = client\n    self._dispatches: dict[int, Dispatch] = {}\n    self._microgrid_id = microgrid_id\n    self._lifecycle_updates_sender = lifecycle_updates_sender\n    self._running_state_change_sender = running_state_change_sender\n    self._next_event_timer = Timer(\n        timedelta(seconds=100), SkipMissedAndResync(), auto_start=False\n    )\n    \"\"\"The timer to schedule the next event.\n\n    Interval is chosen arbitrarily, as it will be reset on the first event.\n    \"\"\"\n\n    self._scheduled_events: list[tuple[datetime, Dispatch]] = []\n    \"\"\"The scheduled events, sorted by time.\n\n    Each event is a tuple of the scheduled time and the dispatch.\n    heapq is used to keep the list sorted by time, so the next event is\n    always at index 0.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor.DispatchingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/dispatch/actor/#frequenz.dispatch.actor-functions","title":"Functions","text":""}]}